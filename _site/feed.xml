<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-14T23:53:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ilimes</title><subtitle>**공부하고 기록하는** 블로그</subtitle><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><entry><title type="html">CH10. 애플리케이션 테스트 관리</title><link href="http://localhost:4000/infoprocessing/post76/" rel="alternate" type="text/html" title="CH10. 애플리케이션 테스트 관리" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post76</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post76/"><![CDATA[<h3 id="애플리케이션-테스트-케이스-설계">애플리케이션 테스트 케이스 설계</h3>

<h4 id="애플리케이션-테스트">애플리케이션 테스트</h4>

<p>애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차</p>

<h4 id="애플리케이션-테스트-원리">애플리케이션 테스트 원리</h4>

<ul>
  <li>완벽한 테스팅은 불가능: 결함을 줄일 수는 있으나, 결함이 없다고 증명할 수 없음</li>
  <li>파레토 법칙(Pareto Principle): 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙</li>
  <li>살충제 패러독스(Pesticide Paradox): 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상</li>
  <li>정황 의존성: 소프트웨어 성격에 맞게 테스트 실시</li>
  <li>오류-부재의 궤변: 요구사항을 충족시키주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음</li>
</ul>

<h4 id="프로그램-실행-여부에-따른-분류">프로그램 실행 여부에 따른 분류</h4>

<ul>
  <li>정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트 (리뷰, 정적 분석)</li>
  <li>동적 테스트: 소프트웨어 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트 (화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트)</li>
</ul>

<h4 id="화이트박스-테스트white-box-test">화이트박스 테스트(White-Box Test)</h4>

<p>원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 (구조 검사)</p>

<h5 id="화이트박스-테스트-유형">화이트박스 테스트 유형</h5>

<ul>
  <li>구문(문장) 커버리지 : 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지</li>
  <li>결정(선택, 분기) 커버리지 : 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건/결정 커버리지 : 전체 조건식 &amp; 개별 조건식 모두 참 한번, 거짓 한 번 결과가 되도록 수행하는 커버리지</li>
  <li>변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지</li>
  <li>다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지</li>
  <li>기본 경로 커버리지 : 수행 가능한 모든 경로를 테스트 하는 기법</li>
  <li>제어 흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법</li>
  <li>데이터 흐름 테스트 : 제어 흐름 그래프에 사용현황 추가한 테스트 기법</li>
</ul>

<h4 id="블랙박스-테스트black-box-test">블랙박스 테스트(Black-Box Test)</h4>

<p>사용자의 요구사항 명세를 보면서 수행하는 테스트 (기능 검사)</p>

<h5 id="블랙박스-테스트-유형">블랙박스 테스트 유형</h5>

<ul>
  <li>동등 분할 테스트 : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법</li>
  <li>경곗값 분석 테스트 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법</li>
  <li>결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트</li>
  <li>상태 전이 테스트 : 이벤트에 의해 어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트</li>
  <li>유스케이스 테스트 : 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트</li>
  <li>분류 트리 테스트 : SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계하여 테스트</li>
  <li>페어와이즈 테스트 : 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식</li>
  <li>원인-결과 그래프 테스트 : 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선정하여 테스트</li>
  <li>비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트</li>
</ul>

<h4 id="테스트-시각에-따른-분류">테스트 시각에 따른 분류</h4>

<ul>
  <li>검증(Verification): 소프트웨어 개발 과정을 테스트, 개발자 또는 시험자의 시각</li>
  <li>확인(Validation): 소프트웨어 결과를 테스트, 사용자 시각</li>
</ul>

<h4 id="테스트-목적에-따른-분류">테스트 목적에 따른 분류</h4>

<ul>
  <li>회복 테스트(Recovery Testing): 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트 하는 기법</li>
  <li>안전 테스트(Security Testing): 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법</li>
  <li>성능 테스트(Perfomance Testing): 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법</li>
  <li>구조 테스트(Structure Testing): 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법</li>
  <li>회귀 테스트(Refression Testing): 시스템의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트</li>
  <li>병행 테스트(Parallel Testing): 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법</li>
</ul>

<h4 id="성능-테스트의-상세-유형">성능 테스트의 상세 유형</h4>

<ul>
  <li>부하 테스트(Load Testing): 시스템에 부가를 계속 증가시켜 시스템의 임계점을 찾는 테스트</li>
  <li>강도 테스트(Stress Testing): 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 테스트</li>
  <li>스파이크 테스트(Spike Testing): 짧은 시간에 사용자가 몰릴 때 시스템의 반응 층정 테스트</li>
  <li>내구성 테스트(Endurance Testing): 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트</li>
</ul>

<h4 id="테스트-종류에-따른-분류">테스트 종류에 따른 분류</h4>

<ul>
  <li>명세 기반 테스트(블랙박스 테스트): 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트 하는 기법</li>
  <li>구조 기반 테스트(화이트박스 테스트): 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법</li>
  <li>경험 기반 테스트(블랙박스 테스트): 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트</li>
</ul>

<h4 id="테스트-케이스test-case">테스트 케이스(Test Case)</h4>

<p>사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서</p>

<h4 id="테스트-오라클test-oracle">테스트 오라클(Test Oracle)</h4>

<p>테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법</p>

<h5 id="테스트-오라클-종류">테스트 오라클 종류</h5>

<ul>
  <li>참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 제공하는 오라클</li>
  <li>샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클</li>
  <li>휴리스틱(Heuristic) 오라클: 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정(휴리스틱)으로 처리하는 오라클</li>
  <li>일관성 검사(Consistent) 오라클: 애플리케이션 변경이 있을 때, 수행 전과후의 결괏값이 동일한지 확인하는 오라클</li>
</ul>

<h4 id="테스트-레벨test-level">테스트 레벨(Test Level)</h4>

<p>함께 편성되고 관리되는 테스트 활동의 그룹</p>

<h5 id="테스트-레벨-종류">테스트 레벨 종류</h5>

<ul>
  <li>단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트 하는 단계</li>
  <li>통합 테스트: 단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</li>
  <li>시스템 테스트: 개발된 소프트웨어가 정상적으로 수행되는지 검증하는 테스트</li>
  <li>인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트</li>
</ul>

<h4 id="소프트웨어-개발단계">소프트웨어 개발단계</h4>

<p>요구사항 → 분석 → 설계 → 구현</p>

<h4 id="테스트-단계">테스트 단계</h4>

<p>단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트</p>

<h4 id="인수-테스트">인수 테스트</h4>

<ul>
  <li>사용자 인수 테스트: 사용자가 시스템 사용의 적절성 여부를 확인</li>
  <li>운영상의 인수 테스트: 시스템 관리자가 시템 인수 시 수행하는 테스트 기법</li>
  <li>계약 인수 테스트: 계약상의 인수/검수 조건을 준수하는지 여부를 확인</li>
  <li>규정 인수 테스트: 소프트웨어가 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인</li>
  <li>알파 테스트: 개발자의 장소에서 사용자가 개발자와 함께 행하는 테스트 기법</li>
  <li>베타 테스트: 실제 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 테스트</li>
</ul>

<h4 id="테스트-시나리오test-scenario">테스트 시나리오(Test Scenario)</h4>

<p>테스트 수행을 위한 여러 테스트 케이스의 집합, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서</p>

<h3 id="애플리케이션-통합-테스트">애플리케이션 통합 테스트</h3>

<h4 id="단위-테스트unit-test">단위 테스트(Unit Test)</h4>

<p>개별적인 모듈(또는 컴포넌트)을 테스트</p>

<h4 id="목mock-객체-생성-프레임워크">목(Mock) 객체 생성 프레임워크</h4>

<p>객체 지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존하는데 이런 경우 메서드를 고립화하여 테스트하는 것이 불가능하므로 독집적인 컴포넌트 테스트를 위해서는 스텁의 객체 지향 버전인 목 객체가 필요하다</p>

<h5 id="목-객체-유형-더미-객체-테스트-스텁-테스트-드라이버-테스트-스파이-가짜-객체">목 객체 유형: 더미 객체, 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체</h5>

<h4 id="통합-테스트intergration-test">통합 테스트(Intergration Test)</h4>

<p>단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</p>

<h5 id="통합-테스트-수행-방법-간-비교">통합 테스트 수행 방법 간 비교</h5>

<ul>
  <li>빅뱅 테스트: 모든 모듈을 동시에 통합 후 테스트 수행
    <ul>
      <li>드라이브/스텁: 드라이버/스텁 없이 실제 모듈로 테스트</li>
    </ul>
  </li>
  <li>상향식 테스트: 최하위 모듈부터 점진적으로 상위 모듈과 함께 테스트
    <ul>
      <li>드라이브/스텁: 테스트 드라이버 필요</li>
    </ul>
  </li>
  <li>하향식 테스트: 최상위 모듈부터 하위 모듈들을 통합하면서 테스트
    <ul>
      <li>드라이브/스텁: 테스트 스텁 필요</li>
    </ul>
  </li>
  <li>샌드위치 테스트: 상위는 하향식+하위는 상향식 테스
    <ul>
      <li>드라이브/스텁: 테스트스텁, 드라이버 필요</li>
    </ul>
  </li>
</ul>

<h4 id="테스트-자동화-도구">테스트 자동화 도구</h4>

<p>반복적인 테스트 작업을 스크립트 형태로 구현함으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 있는 방법</p>

<h4 id="테스트-자동화-도구-유형">테스트 자동화 도구 유형</h4>

<ul>
  <li>정적 분석 도구(Static Analysis Tools): 만들어진 애플리케이션을 실행하지 않고 분석하는 도구</li>
  <li>테스트 실행 도구(Test Execution Tools): 테스트를 위해 작성된 스크립트를 실행하고, 스크립트 언어를 사용하여 테스트를 실행하는 도구</li>
  <li>성능 테스트 도구(Perfomance Test Tools): 가상의 사용자를 생성하고 테스트를 수행하여 목표를 달성했는지 확인 하는 도구</li>
  <li>테스트 통제 도구(Test Control Tools): 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구</li>
  <li>테스트 하네스 도구(Test Harness Tools): 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구</li>
</ul>

<h4 id="테스트-하네스-구성요소-테스트-드라이버-테스트-스텁-테스트-슈트-테스트-케이스-테스트-시나리오-테스트-스크립트-목-오브젝트">테스트 하네스 구성요소: 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 시나리오, 테스트 스크립트, 목 오브젝트</h4>

<h4 id="소프트웨어-결함-개발자-오류로-인해-만들어지는-문서-또는-코딩상의-결점으로-개발자가-설계한-것과-다르게-동작하거나-다른-결과가-발생하는-현상">소프트웨어 결함: 개발자 오류로 인해 만들어지는 문서 또는 코딩상의 결점으로 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 현상</h4>

<h4 id="테스트-결함-관리-단계별-테스트-수행-후-발생한-결함의-재발-방지와-유사-결함-발견-시-처리-시간-단축을-위해-결함을-추적하고-관리하는-활동">테스트 결함 관리: 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동</h4>

<h4 id="결함-분석-방법">결함 분석 방법</h4>

<ul>
  <li>구체화: 결함의 원인을 찾기 위해 결함을 발생기킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법</li>
  <li>고립화: 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법</li>
  <li>일반화: 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법</li>
</ul>

<h4 id="테스트-커버리지test-coverage">테스트 커버리지(Test Coverage)</h4>

<p>주어진 테스트 케이스에 의해 수행되는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준</p>

<h4 id="테스트-커버리지-유형">테스트 커버리지 유형</h4>

<ul>
  <li>기능 기반 커버리지: 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법</li>
  <li>라인 커버리지: 전체 소스 코드의 라인수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인수를 측정하는 방법</li>
  <li>코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법</li>
</ul>

<h4 id="결함-심각도별-분류">결함 심각도별 분류</h4>

<p>단순 결함(미관상 안좋음) → 경미한 결함(표준위반) → 보통 결함(사소한 기능 오작동) → 주요 결함(기능 장애) → 치명적 결함(데이터손실)</p>

<h4 id="결함-우선순위">결함 우선순위</h4>

<p>낮음(Low) → 보통(Medium) → 높음(High) → 결정적(Critical)</p>

<h3 id="애플리케이션-성능-개선">애플리케이션 성능 개선</h3>

<ul>
  <li>tch: 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생</li>
  <li>연결 누수(Connection Leak): DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생</li>
  <li>부적절한 커넥션 풀 크기(Connection Pool Size): 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생할 가능성 존재</li>
  <li>확정(Commint) 관련: 트랜잭션이 확정 되지 않고 커넥션 풀에 반환될 떄 성능 저하 가능성 존재</li>
</ul>

<h4 id="베드-코드bad-code-프로그램-로직이-복잡하고-다른-개발자들이-이해하기-어려운-코드">베드 코드(Bad Code): 프로그램 로직이 복잡하고 다른 개발자들이 이해하기 어려운 코드</h4>

<ul>
  <li>베드 코드 사례
    <ul>
      <li>외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드</li>
      <li>스파게티 코드: 소스 코드가 복잡하게 얽힌 모습, 정상 작동 하지만 코드의 작동을 파악하기 어려운 코드</li>
      <li>알 수 없는 변수명: 변수나 메서드에 대한 이름 정의를 알 수 없는 코드</li>
      <li>로직 중복: 동일한 처리 로직이 중복되게 작성된 코드</li>
    </ul>
  </li>
</ul>

<h4 id="클린-코드clean-code">클린 코드(Clean Code)</h4>

<p>가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드</p>

<ul>
  <li>클린 코드 특징: 가독성이 높아 쉽게 이해됨, 개선도 쉬움, 버그찾기도 쉬워 프래그래밍 속도 빨라짐</li>
  <li>클린 코드 작성 원칙: 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화</li>
</ul>

<h4 id="리팩토링refactoring">리팩토링(Refactoring)</h4>

<p>기능을 변경하지 않고, 복잡한 소스코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="테스트" /><category term="애플리케이션" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 애플리케이션 테스트 관리]]></summary></entry><entry><title type="html">CH09. 소프트웨어 개발 보안 구축</title><link href="http://localhost:4000/infoprocessing/post75/" rel="alternate" type="text/html" title="CH09. 소프트웨어 개발 보안 구축" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post75</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post75/"><![CDATA[<h3 id="소프트웨어-개발-보안-설계">소프트웨어 개발 보안 설계</h3>

<h4 id="sw-개발-보안">SW 개발 보안</h4>

<p>소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동</p>

<ul>
  <li>SW 개발 보안 생명주기: 요구사항 명세 → 설계 → 구현 → 테스트 → 유지보수</li>
</ul>

<h4 id="sw-개발-보안-3대-요소">SW 개발 보안 3대 요소</h4>

<ul>
  <li>기밀성(Confidentiality): 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용</li>
  <li>무결성(Integrity): 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음</li>
  <li>가용성(Availability): 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음</li>
</ul>

<h4 id="dosdenial-of-service-공격">DoS(Denial of Service) 공격</h4>

<p>시스템을 악의적으로 공객해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격</p>

<h4 id="dos-공격의-종류">DoS 공격의 종류</h4>

<ul>
  <li>SYN 플러딩(SYN Flooding): 서버의 동시 가용 사용자수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격</li>
  <li>UDP 플러딩(UDP Flooding): 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키는 공격</li>
  <li>스퍼프(Smurf)/스머핑(Smurfing): 출발지 주소를 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo패킷을 직접 브로드캐스팅하여 마비시키는 공격</li>
  <li>죽음의 핑(PoD: Ping of Death): ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하여 정상적인 서비스를 못하도록 하는 공격</li>
  <li>랜드 어택(Land Attack): 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보내 시스템의 가용성을 침해하는 공격</li>
  <li>티어 드롭(Tear Drop): IP패킷의 재조합 과정에서 잘못된 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격</li>
  <li>봉크(Bonk)/보잉크(Boink): 프로토콜의 오류 제어를 이용한 공격기법</li>
</ul>

<h4 id="ddosdistributed-denial-of-service">DDoS(Distributed Denial of Service)</h4>

<p>여러 대의 공격자를 분산 배치하여 동시에 동작하게함으로써 특정 사이트를 공격하는 기법</p>

<h4 id="ddos-공격도구">DDos 공격도구</h4>

<ul>
  <li>Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구</li>
  <li>Tribe Flood Network: 많은 소스에서 하나 혹은 여러개의 목표 시스템에 대해 서비스 거부 공격을 수행할 수 있는 도구</li>
  <li>Stacheldraht: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구</li>
</ul>

<h4 id="dos와-ddos-차이">DoS와 DDoS 차이</h4>

<ul>
  <li>DoS는 직접 공격, DDoS는 공격하도록 지시</li>
  <li>DoS는 한 사람에 의해 공격을 감행, DDoS는 수많은 감염 호스트를 통해 공격을 감행</li>
</ul>

<h4 id="drdosdistributed-reflection-dos">DRDoS(Distributed Reflection DoS)</h4>

<p>공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부(DoS)가 되는 공격</p>

<h4 id="세션-하이재킹session-hijacking">세션 하이재킹(Session Hijacking)</h4>

<p>TCP의 세션 관리 취약점을 이용한 공격 기법, 케빈 미트닉이 사용</p>

<h4 id="애플리케이션-공격기법">애플리케이션 공격기법</h4>

<ul>
  <li>HTTP GET 플러딩: 과도한 Get 메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격</li>
  <li>Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 대상 웹 서버와 연결상태를 장시간 지속시키고 연결자원을 모두 소진시키는 서비스 거부 공격</li>
  <li>RUDY: 요청 헤더의 Content-Length를 비상장으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격</li>
  <li>Slow HTTP Read DoS: 다수 HTTP 패킷을 지속적으로 전송하여 웹서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격</li>
  <li>Hulk DoS: 공격자가 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET요청을 발생시키는 서비스 거부 공격</li>
  <li>Hash DoS: 많은 수의 파라미터를 POST방식으로 웹서버로 전달하여 다수의 해시 출돌을 발생시켜서 자원을 소모시키는 서비스 거부 공격</li>
</ul>

<h4 id="네트워크-공격">네트워크 공격</h4>

<ul>
  <li>스니핑: 공격대상의 데이터만 몰래 들여다보는 수동적 공격 기법</li>
  <li>네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구</li>
  <li>패스워드 크래킹
    <ul>
      <li>사전 크래킹: ID와PW가 될 가능성이 있는 단어를 파일로 만들어 파일의 단어를 대입하여 크랙하는 공격 기법</li>
      <li>무차별 크래킹: 무작위로 패스워드 자리에 대입하여 패스워드를 알아내는 공격 기법</li>
      <li>패스워드 하이브리드 공격: 사전공격+무차별공격</li>
      <li>레인보우 테이블 공격: 크래킹 하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법</li>
    </ul>
  </li>
  <li>IP 스푸핑: 침입자가 인증된 컴퓨팅 시스템인 것처럼 속여서 인증된 호스트의 IP 주소로 위조하여 타깃에 정송하는 공격 기법</li>
  <li>ARP 스푸핑: 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송</li>
  <li>ICMP Redirect 공격: 스니핑 시스템을 네트워크에 존재하는 또다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격 기법</li>
  <li>트로이 목마: 악성 루틴이 숨어있는 프로그램, 실행하면 악성 코드를 실행</li>
</ul>

<h4 id="버퍼-오버플로우buffer-overflow-공격">버퍼 오버플로우(Buffer Overflow) 공격</h4>

<p>메모리에 할당도니 버퍼 크기를 초과하는 양의 데이터를 입력하여 프로세스의 흐름을 변경시켜서 악성 코드를 실행 시키는 공격 기법</p>

<h4 id="백도어backdoor">백도어(Backdoor)</h4>

<p>허가받지 않고 시스템에 접속하는 권리, 정상적인 인증 절차를 우회하는 기법</p>

<h4 id="보안-관련-용어">보안 관련 용어</h4>

<ul>
  <li>스피어 피싱(Spear Phishing): 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도하여 사용자의 개인정보 탈취하는 공격기법</li>
  <li>스미싱(Smishing): SMS(문자)를 이용하여 개인 비밀정보를 요구하거나 휴대폰 소액 결제를 유도하는 피싱 공격</li>
  <li>큐싱(Qshing): QR코드를 통해 악성 앱을 내려받도록 유도하여 금융 정보 등을 뺴내는 피싱 공격</li>
  <li>봇넷(Botnet): 악성 프로그램이감염되어 있는 컴퓨터들이 네트워크로 연결된 형태</li>
  <li>APT 공격(Advanced Persistent Threat): 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법</li>
  <li>공급망 공격(Supply Chain Atack): SW개발사의 네트워크에 침투하여 악의적 코드를 삽입, 서버 배포하여 사용자가 설치 또는 업데이트시에 자동적으로 감염되도록 하는 공격 기법</li>
  <li>제로데이 공격(Zero Day Attack): 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격 기법</li>
  <li>웜(Worm): 스스로 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 프로그램</li>
  <li>악성 봇(Malicious Bot): 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램 또는 코드</li>
  <li>사이버 킬체인(Cyber Kill Chain): 공격형 방위시스템, APT공격방어 분석 모델</li>
  <li>랜섬웨어(Ransomware): 시스템의 파일을 암호화하여 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어</li>
  <li>이블 트윈(Evil Twin) 공격: 핫스팟에 연결한 무선 사용자들의 정보르 탈취하는 무선 네트워크 공격 기법</li>
</ul>

<h4 id="서버-인증의-기능">서버 인증의 기능</h4>

<p>스니핑 방지(SSL인증서 설치), 피싱 방지, 데이터 변조 방지, 기업 신뢰도 향상(기업 인증)</p>

<h4 id="인증-기술의-유형">인증 기술의 유형</h4>

<ul>
  <li>지식기반 인증: 사용자가 기억하고 있는 지식 (ID/PW)</li>
  <li>소지기반 인증: 소지하고 있는 사용자 물품 (공인인증서, OTP)</li>
  <li>생체기반 인증: 고유한 사용자의 생체 정보 (홍채, 얼굴, 지문)</li>
  <li>특정기반 인증: 사용자의 특징을 활용 (서명, 몸짓)</li>
</ul>

<h4 id="접근-통제-기법">접근 통제 기법</h4>

<ul>
  <li>식별(Identification): 자신이 누구라고 시스템에 밝히는 행위</li>
  <li>인증(Authentication): 주체의 신원을 검증하기 위한 활동</li>
  <li>인가(Authorization): 인증된 주체에게 접근을 허용하는 활동</li>
  <li>책임추적성(Accountability): 주체의 접근을 추적하고 행동을 기록하는 활동</li>
</ul>

<h4 id="서버-접근-통제-유형">서버 접근 통제 유형</h4>

<ul>
  <li>임의적 접근 통제(DAC): 신분에 근거하여 객체에 대한 접근을 제한하는 방법</li>
  <li>강제적 접근 통제(MAC): 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법</li>
  <li>역할 기반 접근 통제(RBAC): 중앙 관리자가 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법</li>
</ul>

<h4 id="접근-통제-보호-모델">접근 통제 보호 모델</h4>

<ul>
  <li>벨-라파듈라 모델(BLP): 미 국방부지원 보안 모델, 보안 요소 중 기밀성을 가종하며 강제적 정책에 의해 접근 통제하는 모델
    <ul>
      <li>No Read Up: 보안수준이 낮은 주체는 보안 수준이 높은 객체를 읽어서는 안 됨</li>
      <li>No Write Down: 보안수준이 높은 주체는 보안 수준이 낮은 객체에 기록하면 안 됨</li>
    </ul>
  </li>
  <li>비바 모델: 무결성을 보장하는 최초 모델
    <ul>
      <li>No Read Down: 높은 등급의 주체는 낮은 등급의 객체를 읽을 수 없음</li>
      <li>No Wirte Up: 낮은 등급의 주체는 상위 등급의 객체를 수정 할 수 없음</li>
    </ul>
  </li>
</ul>

<h4 id="암호-알고리즘encryption-algorithm-데이터의-무결성-및-기밀성-확보를-위해-정보를-쉽게-해독할-수-없는-형태로-변환하는-기법">암호 알고리즘(Encryption Algorithm): 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독할 수 없는 형태로 변환하는 기법</h4>

<ul>
  <li>양방향 방식: 대칭 키 암호 방식, 비대칭 키 암호 방식</li>
  <li>일방향 해시함수 방식: MDC, MAC</li>
</ul>

<h4 id="대칭-키-암호-방식-암호화와-복호화에-같은-암호-키를-쓰는-알고리즘">대칭 키 암호 방식: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘</h4>

<ul>
  <li>블록 암호 방식: 고정 길이의 블록을 암호화하여 반복하는 알고리즘(EDS, AES, SEED)</li>
  <li>스트림 암호 방식: 매우긴 주기의 난수열을 발새이켜 평문과 더불어 암호문을 생성하는 방식(RC4)</li>
</ul>

<h4 id="비대칭-키-암호-방식">비대칭 키 암호 방식</h4>

<p>개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식, 공개키는 누구나 알수 있으나 개인키는 키의 소유자만 알고 있어야 한다. (RSA, 디피-헬만)</p>

<h4 id="일방향-암호-방식해시-암호-방식">일방향 암호 방식(해시 암호 방식)</h4>

<p>임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식</p>

<ul>
  <li>MAC: 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장</li>
  <li>MDC: 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장</li>
</ul>

<h4 id="대칭키-암호화-알고리즘">대칭키 암호화 알고리즘</h4>

<ul>
  <li>DES: 1975년 IBM 개발, 대칭 키 기반</li>
  <li>SEED: 1999년 한국인터넷진흥원(KISA) 개발</li>
  <li>AES: 2001년 미국 표준기술 연구소(NIST) 개발</li>
  <li>ARIA: 2004년 국가정보원과 산학연구협회가 개발</li>
  <li>IDEA: DES 대체, 스위스 연방기술기관 개발</li>
  <li>LFSR: 선형함수로 계산되는 구조로 되어있는 스트임 암호화 알고리즘</li>
</ul>

<h4 id="비대칭-키-암호화-알고리즘">비대칭 키 암호화 알고리즘</h4>

<ul>
  <li>디피-헬만: 최초의 공개키 알고리즘</li>
  <li>RSA: 1977년 MIT 개발</li>
  <li>ElGamal: 1984년 ElGamal 개발</li>
  <li>ECC: 1985년 RSA 대안으로 개발</li>
</ul>

<h4 id="해시-암호화-알고리즘">해시 암호화 알고리즘</h4>

<ul>
  <li>MD5: MD4 개선한 암호화 알고리즘, 파일의 무결성 검사에 사용</li>
  <li>SHA-1: 1993년 NSA에 미국 정부 표준 지정</li>
  <li>SHA-256/384/512: 256비트의 해시값을 생성하는 해시함수</li>
  <li>HAS-160: 국내 표준 서명 알고리즘</li>
  <li>HAVAL: 메시지를 1024bits 블록으로 나눔</li>
</ul>

<h4 id="ipsecinternet-protocol-security">IPSec(Internet Protocol Security)</h4>

<p>무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜</p>

<h4 id="sslsecure-socket-layertlstransport-layer-security">SSL(Secure Socket Layer)/TLS(Transport Layer Security)</h4>

<p>클라이언트와 서버간의 웹데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜</p>

<h4 id="s-httpsecure-hypertexrt-transfer-protocol">S-HTTP(Secure Hypertexrt Transfer Protocol)</h4>

<p>웹상에서 네트워크 트래픽을 암호화 하는 방법</p>

<h3 id="소프트웨어-개발-보안-구현">소프트웨어 개발 보안 구현</h3>

<h4 id="시큐어-코딩-가이드">시큐어 코딩 가이드</h4>

<p>설계 및 구현 단계에서 해킹 등의 공격을 유발할 가능성이 있는 잠재적인 보안 취약점을 사전에 제거하고, 외부 공격으로부터 안전한 소프트웨어를 개발하는 기법</p>

<ul>
  <li>보안 취약점: 운영 단계의 보안 리스크</li>
  <li>보안 약점: 개발 단계의 보안 리스크</li>
</ul>

<h4 id="입력-데이터-검증-및-표현">입력 데이터 검증 및 표현</h4>

<p>입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목</p>

<h4 id="입력-데이터-검증-및-표현-취약점">입력 데이터 검증 및 표현 취약점</h4>

<ul>
  <li>XSS(Cross Site Script): 검증되지 않은 외부 입력 데이터가 포함된 웹페이지를 사용자가 열람함으로써 웹페이제 포함된 부적절한 스크립트가 실행되는 공격
    <ul>
      <li>대책: 특수문자 필터링, HTML태그 사용금지</li>
    </ul>
  </li>
  <li>사이트 간 요청 위조(CSRF: Cross-Site REquest Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
    <ul>
      <li>대책: 입력화면 폼 POS방식 사용, 세션별 CSRF토큰 사용</li>
    </ul>
  </li>
  <li>SQL 삽입(Injection): 악의적인 SQL구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격
    <ul>
      <li>대책: 변수 타입 지정, 사용자 입력값 모두 체크하여 필터링</li>
    </ul>
  </li>
</ul>

<h4 id="보안-기능">보안 기능</h4>

<p>소프트웨어 개발 단계에서 인증, 접근제어, 기밀성, 암호화, 권한 관리 등을 적절하게 구현하기 위한 보안 점검 항목</p>

<h4 id="에러-처리">에러 처리</h4>

<p>프로그램 실행시 발생하는 에러를 예외 처리하지 못하거나, 에러에 중요한 정보가 포함될 때 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목</p>

<h4 id="세션-통제">세션 통제</h4>

<p>세션과 관련되어 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목</p>

<h4 id="코드-오류">코드 오류</h4>

<p>개발자의 실수로 발생하는 프로그램 오류를 예방하기 위한 보안 점검 항목</p>

<h4 id="캡슐화">캡슐화</h4>

<p>외부에 은닉이 필요한 중요한 데이터와 인가되지 않은 사용자에게 노출되지 않게 보안 취약점을 예방을 위한 보안 검증 항목</p>

<h4 id="api-오용">API 오용</h4>

<p>보안에 취약한 API를 오용하여 발생할 수 있느 보안 취약점 예방을 위한 보안 검증 항목</p>

<h4 id="네트워크-보안-솔루션">네트워크 보안 솔루션</h4>

<ul>
  <li>방화벽(Firewall) : 기업 내부, 외부 간 트래픽을 모니터링 하여 시스템의 접근을 허용/차단하는 시스템</li>
  <li>웹 방화벽 (WAF: Web Application Firewall): 웹 애플리케이션 보안에 특화된 보안 장비</li>
  <li>네트워크 접근 제어(NAC: Network Access Control) : 단말기가 내부 네트워크에 접속을 시도할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션</li>
  <li>침입 탐지 시스템(IDS: Intrusion Detection System) : 네트워크에 발생하는 이벤트를 모니터링하고, 보안정책 위반 행위를 실시간으로 탐지하는 시스템</li>
  <li>침입 방지 시스템(IPS: Intrusion Prevention System) : 네트워크에 대한 공격이나 침입을 실시간적으로 차단하고, 유해드래칙에 대해 능동적으로 조치하는 시스템</li>
  <li>무선 침입 방지 시스템(WIPS: Wireless Intrusion Prevention System) : 무선 단말기의 접속을 자동 탐지 및 차단하고 보안에 취약한 무선 공유기를 탐지하는 시스템</li>
  <li>통합 보안 시스템(UTM: Unified Threat Management) : 다양한 보안 장비의 기능을 하나의 장비로 통합하여 제공하는 시스템</li>
  <li>가상사설망(VPN: Virtual Private Network) : 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용해 마치 전용망을 사용하는 효과를 가지는 보안 솔루션</li>
</ul>

<h4 id="시스템-보안-솔루션">시스템 보안 솔루션</h4>

<ul>
  <li>스팸 차단 솔루션(Anti-Spam Solution): 매일 서버 앞단에 위칳하여 Proxy 메일 서버로 동작</li>
  <li>보안 운영체제(Secure OS): 컴퓨터 운영체제의 커널에 보안기능을 추가한 솔루션</li>
</ul>

<h4 id="콜텐츠-유출-방지-솔루션">콜텐츠 유출 방지 솔루션</h4>

<ul>
  <li>보안 USB: 정보 유출 방지 등의 보안 기능을 갖춘 USB메모리</li>
  <li>데이터 유출 방지(DLP: Data Loss Prevention): 조직 내부의 중요 자료가 외부로 빠져나가는 것을 탐지하고 차단하는 솔루션</li>
  <li>디지털 저작권 관리(DRM): 디지털 저작물에 대한 보호와 관리를 위한 솔루션</li>
</ul>

<h4 id="소프트웨어-개발-보안테스트-유형">소프트웨어 개발 보안테스트 유형</h4>

<ul>
  <li>정적 분석: SW를 실행하지 않고 보안 약점을 분석, 개발 단계</li>
  <li>동적 분석: SW를 실행환경에서 보안 약점 분석, 시험 단계</li>
</ul>

<h4 id="비즈니스-연속성-계획bcp-busniess-continuity-plan">비즈니스 연속성 계획(BCP: Busniess Continuity Plan)</h4>

<p>각종 재해, 장애, 재난으로부터 위기관리 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 비즈니스 연속성을 보장하는 체계</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="software" /><category term="소프트웨어" /><category term="보안" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 소프트웨어 개발 보안 구축]]></summary></entry><entry><title type="html">CH08. 서버 프로그램 구현</title><link href="http://localhost:4000/infoprocessing/post74/" rel="alternate" type="text/html" title="CH08. 서버 프로그램 구현" /><published>2023-03-11T00:00:00+09:00</published><updated>2023-03-11T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post74</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post74/"><![CDATA[<h3 id="개발환경-구축">개발환경 구축</h3>

<h4 id="개발-도구-분류">개발 도구 분류</h4>

<ul>
  <li>빌드 도구</li>
</ul>

<p>작성한 코드의 빌드 및 배포를 수행하는 도구 (Ant, Maven, Gradle)</p>

<ul>
  <li>구현 도구</li>
</ul>

<p>코드의 작성과 디버깅, 수정 등과 같이 작업 시 사용되는 도구 (Eclipse, InteliJ, VS)</p>

<ul>
  <li>테스트 도구</li>
</ul>

<p>코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구 (xUnit, PMD, Sonar)</p>

<ul>
  <li>형상 관리 도구</li>
</ul>

<p>산출물에 대한 버전관리를 위한 도구 (Git, SVN, CVS)</p>

<h4 id="서버-하드웨어-개발환경">서버 하드웨어 개발환경</h4>

<ul>
  <li>웹 서버</li>
</ul>

<p>HTTP를 이용한 요청/응답을 처리 (Apache 웹서버, 구글 웹서버)</p>

<ul>
  <li>웹 애플리케이션 서버(WAS)</li>
</ul>

<p>동적 콘텐츠를 처리하고 제공하기 위해 사용 (Tomcat, Jeus, Resin)</p>

<ul>
  <li>데이터베이스 서버</li>
</ul>

<p>데이터의 수집, 저장을 위한 용도로 사용 (MySql, Oracle, MS-SQL)</p>

<ul>
  <li>파일 서버: 파일 저장 하드웨어로 물리 저장 장치를 활용한 서버(HDD, SSD)</li>
</ul>

<h4 id="소프트웨어-개발환경">소프트웨어 개발환경</h4>

<ul>
  <li>운영체제</li>
</ul>

<p>사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어</p>

<ul>
  <li>미들웨어</li>
</ul>

<p>웹 서버, JVM과 같은 개발 환경의 구성요소로 활용</p>

<ul>
  <li>DBMS</li>
</ul>

<p>데이터의 저장 및 활용을 위해 DBMS를 설치</p>

<h4 id="형상-관리configuration-management">형상 관리(Configuration Management)</h4>

<p>소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동</p>

<ul>
  <li>형상 관리 절차</li>
</ul>

<p>형상식별(대상정의) → 형상 통제(버전관리) → 형상 감사(무결성) → 형상 기록(보고서)</p>

<h4 id="소프트웨어-형상-관리-도구-유형">소프트웨어 형상 관리 도구 유형</h4>

<ul>
  <li>공유 폴더 방식</li>
</ul>

<p>매일 개발이 완료된 파일은 약속된 우치의 공유 폴더에 복사하는 방식 (RCS, SCCS)</p>

<ul>
  <li>클라이언트/서버 방식</li>
</ul>

<p>중앙에 버전 관리 시스템을 항시 동작시키는 방식 (CVS, SVN)</p>

<ul>
  <li>분산 저장소 방식</li>
</ul>

<p>로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식 (Git)</p>

<h4 id="소프트웨어-형상-관리-도구별-특징">소프트웨어 형상 관리 도구별 특징</h4>

<ul>
  <li>CVS(Concurrent Versions System)</li>
</ul>

<p>서버와 클라이언트로 구성되어있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 형상 관리 도구</p>

<ul>
  <li>SVN(Subversion)</li>
</ul>

<p>하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구</p>

<ul>
  <li>RCS(Revision Control System)</li>
</ul>

<p>소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일을 수정을 동시에 할 수 없도록 파일 잠금 방식으로 형상을 관리하는 도구</p>

<ul>
  <li>Bitkeeper</li>
</ul>

<p>중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 형상 관리 도구</p>

<ul>
  <li>Git</li>
</ul>

<p>속도에 중점을 둔 분산형 버전 관리 시스템, 대형 프로젝트에서 효과적이고 유용함</p>

<ul>
  <li>Clear Case</li>
</ul>

<p>복수 서버, 복수 클라이언트 구조, 필요한 서버를 하나씩 추가하여 확장성을 기할 수 있음</p>

<h3 id="공통-모듈-구현">공통 모듈 구현</h3>

<h4 id="모듈module">모듈(Module)</h4>

<p>하나의 완전한 기능을 수행할 수 있는 독립된 실체</p>

<h4 id="모듈화modularity">모듈화(Modularity)</h4>

<p>프로그램 개발 시 생산성과 최적화, 관리에 용이하게 기능 단위로 분할하는 기법</p>

<ul>
  <li>모듈화 원리: 정보은닉, 분할과 정복, 데이터 추상화, 모듈 독립성</li>
</ul>

<h4 id="응집도cohesion">응집도(Cohesion)</h4>

<p>모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소 간 연관 정도</p>

<ul>
  <li>응집도 유형: 우연적 응집도, 논리적 응집도, 시간적 응집도, 절차적 응집도, 통신적 응집도, 순차적 응집도, 기능적 응집도</li>
</ul>

<h4 id="결합도coupling">결합도(Coupling)</h4>

<p>외부 모듈과의 연관도 또는 모듈 간의 상호의존성. 모듈간의 관련성을 측정하는 척도</p>

<ul>
  <li>결합도 유형: 내용 결합도, 공통 결합도, 외부 결합도, 제어 결합도, 스탬프 결합도, 자료 결합도</li>
</ul>

<p>=&gt; 응집도는 높을수록 좋고, 결합도는 낮을수록 좋다.</p>

<h4 id="공통-모듈-구현-절차-dtovo--sql--dao--service--controller--화면-구현">공통 모듈 구현 절차: DTO/VO → SQL → DAO → Service → Controller → 화면 구현</h4>

<ul>
  <li>DTO(Data Transfer Object)</li>
</ul>

<p>프로세스 사이에서 데이터를 전송하는 객체</p>

<ul>
  <li>VO(Value Object)</li>
</ul>

<p>고정 클래스를 가지는 객체</p>

<ul>
  <li>DAO(Data Access Object)</li>
</ul>

<p>특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체</p>

<h4 id="팬인fan-in-및-팬아웃fan-out">팬인(Fan-In) 및 팬아웃(Fan-Out)</h4>

<ul>
  <li>Fan-In</li>
</ul>

<p>어떤 모듈을 제어하는 모듈의 수 / 모듈 자신을 기준으로 모듈에 들어오면 팬인</p>

<ul>
  <li>Fan-Out</li>
</ul>

<p>어떤 모듈에 의해 제어 되는 모듈의 수 / 모듈 자신을 기준으로 모듈에서 나가면 팬아웃</p>

<ul>
  <li>시스템 복잡도를 최적화하기 위해 팬인은 높게, 팬아웃은 낮게 설계 해야한다.</li>
</ul>

<h4 id="공통-모듈-테스트">공통 모듈 테스트</h4>

<p>IDE 도구를 활용하여 개별 공통 모듈에 대한 디버깅을 수행</p>

<ul>
  <li>통합 개발 환경(IDE: Intergrated Developmnet Enviroment)</li>
</ul>

<p>개발에 필요한 다양한 틀을 하나의 인터페이스로 통합 하여 제공하는 환경 (도구: Eclipse, VS, Android Studio, IDEA)</p>

<h4 id="공통-모듈-테이스-종류">공통 모듈 테이스 종류</h4>

<ul>
  <li>화이트박스 테스트</li>
</ul>

<p>소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트</p>

<ul>
  <li>메서드 기반 테스트</li>
</ul>

<p>공통 모듈의 외부에 공개된 메서드 기반 테스트</p>

<ul>
  <li>화면 기반 테스트</li>
</ul>

<p>화면단위로 단위모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트</p>

<ul>
  <li>테스트 드라이버/테스트 스텁 활용 테스트기능을 테스트할 수 있는 화면 또는 하위 모듈이 구현되지 않은 경우
    <ul>
      <li>테스트 드라이버(Test Driver): 하위 모듈은 있지만 상위 모듈은 없는 경우 사용</li>
      <li>테스트 스텁(Test Stub): 상위 모듈은 있지만 하위 모듈은 없는 경우 사용</li>
    </ul>
  </li>
</ul>

<h4 id="junit">Junit</h4>

<p>자바 프로그래밍 언어용 단위테스트 도구</p>

<h3 id="배치-프로그램-구현">배치 프로그램 구현</h3>

<h4 id="배치-프로그램batch-program">배치 프로그램(Batch Program)</h4>

<p>사용자와의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법</p>

<h4 id="배치-프로그램-유형">배치 프로그램 유형</h4>

<ul>
  <li>이벤트 배치</li>
</ul>

<p>사전에 정의해 둔 조건 충족 시 자동으로 실행</p>

<ul>
  <li>온디맨드 배치</li>
</ul>

<p>사용자의 명시적 요구가 있을 때마다 실행</p>

<ul>
  <li>정기 배치</li>
</ul>

<p>정해진 시검에 정기적으로 실행</p>

<h4 id="배치-스케줄러batch-scheduler">배치 스케줄러(Batch Scheduler)</h4>

<p>일괄 처리(Batch Processing) 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원하는 도구</p>

<h4 id="배치-스케줄러-종류">배치 스케줄러 종류</h4>

<ul>
  <li>스프링 배치(Spring Batch)</li>
</ul>

<p>오픈 소스 프레임워크</p>

<ul>
  <li>쿼츠 스케줄러(Quartz Scheduler)</li>
</ul>

<p>수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공(오픈 소스 라이브러리)</p>

<h4 id="corn-표현식">Corn 표현식</h4>

<p>크론 표현식을 통해 배치 수행 시간을 시간 및 주기 등으로 설정</p>

<ul>
  <li>리눅스/유닉스 크론 표현식: 분, 시간, 일, 월, 요일, 연도</li>
  <li>쿼츠 크론 표현식: 초, 분, 시간, 일, 월, 요일, 연도</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="Server" /><category term="서버" /><category term="서버프로그램구현" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 서버 프로그램 구현]]></summary></entry><entry><title type="html">CH07. SQL 응용</title><link href="http://localhost:4000/infoprocessing/post73/" rel="alternate" type="text/html" title="CH07. SQL 응용" /><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post73</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post73/"><![CDATA[<h3 id="데이터베이스-기본">데이터베이스 기본</h3>

<h4 id="트랜잭션transaction">트랜잭션(Transaction)</h4>

<p>인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성, 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위</p>

<h5 id="트랜잭션-특성">트랜잭션 특성</h5>

<ul>
  <li>원자성(Atomicity): 트랜잭션의 연산 전체가 성공 또는 실패되어야 하는 성질 (All or Nothing)</li>
  <li>일관성(Consistency): 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질</li>
  <li>격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않어야 한다는 성질</li>
  <li>영속성(Durability): 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질</li>
</ul>

<h5 id="트랜잭션-제어어tcl-transaction-control-language">트랜잭션 제어어(TCL, Transaction Control Language)</h5>

<p>트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어</p>

<ul>
  <li>TCL 명령어
    <ul>
      <li>COMMIT: 트랜잭션을 메모리에 영구적으로 저장하는명령어</li>
      <li>ROLLBACK: 트랜잭션 내역의 저장을 무효화시키는 명령어</li>
      <li>CHECKPOINT(SAVEPOINT): ROLLBACK을 위한 시점을 지정하는 명령어</li>
    </ul>
  </li>
</ul>

<h4 id="데이터-정의어ddl-data-definition-language">데이터 정의어(DDL: Data Definition Language)</h4>

<p>DB를 구축하거나 수정할 목적으로 사용하는 언어</p>

<h4 id="ddl-대상">DDL 대상</h4>

<ul>
  <li>도메인(Domain): 하나의 속성이 가질 수 있는 원자값들의 집합</li>
  <li>스키마(Schema): 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
    <ul>
      <li>외부 스키마, 개념 스키마, 내부 스키마</li>
    </ul>
  </li>
  <li>테이블(Table): 데이터 저장 공간</li>
  <li>뷰(View): 하나 이상의 물리 테이블에서 유도되는 가상의 테이블</li>
  <li>인덱스(Index): 검색을 빠르게 하기 위한 데이터 구조
    <ul>
      <li>인덱스 종류
        <ul>
          <li>순서 인덱스(Ordered Index): 데이터가 정렬된 순서로 생성되는 인덱스</li>
          <li>해시 인덱스(Hash Index): 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스</li>
          <li>비트맵 인덱스(Bitmap Index): bit 값인 0 또는 1로 변호나하여 인덱스 키로 사용하는 인덱스</li>
          <li>함수기반 인덱스(Functional Index): 수식이나 함수를 적용하여 만든 인덱스</li>
          <li>단일 인덱스(Single Index): 하나의 컬럼으로만 구성한 인덱스</li>
          <li>결합 인덱스(Concatenated Index): 두 개 이상의 컬럼으로 구성한 인덱스</li>
          <li>클러스터드 인덱스(Clustered Index): 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식 (검색 빠름)</li>
          <li>넌클러스터드 인덱스(Non-Clustered Index): 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식 (데이터 삽입, 삭제 시 데이터 재정렬해야함)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="ddl-명령어">DDL 명령어</h5>

<p>CREATE(생성), ALTER(수정), DROP(삭제)</p>

<ul>
  <li>CASCADE: 제거할 요소를 참조하는 다른 모든 개체를 함께 제거</li>
  <li>RESTRICT: 다른 개체가 제거할 요소를 참조중일 떄는 제거를 취소</li>
</ul>

<h5 id="데이터-조작어dml-data-manipulation-language">데이터 조작어(DML: Data Manipulation Language)</h5>

<p>저장된 데이터를 실질적으로 관리하는데 사용되는 언어</p>

<ul>
  <li>DML 유형: SELECT(조회), INSERT(삽입), UPDATE(수정), DELETE(삭제)</li>
</ul>

<h5 id="데이터-제어어dcl-data-control-language">데이터 제어어(DCL: Data Control Language)</h5>

<p>데이터의 보안, 무결성, 회복, 병행 제어등을 정의하는데 사용하는 언어</p>

<ul>
  <li>DCL 유형
    <ul>
      <li>GRANT: 사용 권한 부여</li>
      <li>REVOKE: 사용 권한 취소</li>
    </ul>
  </li>
</ul>

<h3 id="응용-sql-작성하기">응용 SQL 작성하기</h3>

<h4 id="데이터-분석-함수-종류">데이터 분석 함수 종류</h4>

<ul>
  <li>집계 함수: 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수</li>
  <li>그룹 함수: 소그룸 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수</li>
  <li>윈도 함수: 데이터베이스를 사용한 오라인 부석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능</li>
</ul>

<h3 id="절차형-sql-활용하기">절차형 SQL 활용하기</h3>

<h4 id="절차형-sqlprocedural-sql">절차형 SQL(Procedural SQL)</h4>

<p>SQL언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어</p>

<h5 id="절차형-sql-종류">절차형 SQL 종류</h5>

<ul>
  <li>프로시저(Procedure): 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 커리의 집합</li>
  <li>사용자 정의 함수(User-Defined FUnction): SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL</li>
  <li>트리거(Trriger): 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL</li>
</ul>

<h3 id="데이터-조작-프로시저-최적화">데이터 조작 프로시저 최적화</h3>

<p>쿼리 성능 개선: 최소의 시간으로 우너하는 결과를 얻도록 프로시저를 수정하는 작업</p>

<h4 id="sql-성능-개선-절차">SQL 성능 개선 절차</h4>

<p>문제있는 SQL식별 → 옵티마이저 통계확인 → SQL문 재구성 → 인덱스 재구성 → 실행계획 유지관리</p>

<h4 id="옵티마이저optimizer">옵티마이저(Optimizer)</h4>

<p>SQL이 가장 효율적으로 수행되도록 최적의 경로를 찾아 주는 모듈</p>

<ul>
  <li>옵티마이저 유형
    <ul>
      <li>규칙기반 옵티마이저(RBO): 사전에 정의해둔 규칙에 의거하여 경로를 찾는 규칙 기반 옵티마이저</li>
      <li>비용기반 옵티마이저(CBO): 각 DBMS마다 고유의 알고리즘에 따라 산출되는 비용으로 최적의 경로를 찾는 비용기반 옵티마이저</li>
    </ul>
  </li>
</ul>

<h4 id="힌트hint">힌트(Hint)</h4>

<p>실행하려는 SQL문에 사전에 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법</p>

<ul>
  <li>옵티마이저의 실행 계획을 원하는 대로 변경할 수 있게 한다.</li>
  <li>옵티마이저는 명시적인 힌트를 통해 실행 계획을 변경한다.</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="SQL" /><category term="SQL응용" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - SQL 응용]]></summary></entry><entry><title type="html">CH05. 인터페이스 구현</title><link href="http://localhost:4000/infoprocessing/post72/" rel="alternate" type="text/html" title="CH05. 인터페이스 구현" /><published>2023-03-04T00:00:00+09:00</published><updated>2023-03-04T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post72</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post72/"><![CDATA[<h3 id="인터페이스-기능-구현">인터페이스 기능 구현</h3>

<h4 id="컴포넌트-명세서">컴포넌트 명세서</h4>

<p>컴포넌트 개요, 부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세</p>

<h4 id="인터페이스-명세서">인터페이스 명세서</h4>

<p>컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서</p>

<h4 id="jsonjavascript-object-notation">JSON(Javascript Object Notation)</h4>

<p>속성-값 쌍 또는 “키-값 쌍”으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 테스트를 사용하는 개방형 표준 포맷, AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷</p>

<h4 id="xmlextensible-markup-language">XML(Extensible Markup Language)</h4>

<p>HTML의 단점을 보완한 인터넷 언어로, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어</p>

<h4 id="ajaxasynchronous-javascript-and-xml">AJAX(Asynchronous Javascript And XML)</h4>

<p>자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML데이터를 교환하고 조작하는 웹 기술, XMLHttpRequest객체(비동기 통신을 담당하는 JS 객체)를 이용해서 필요한 일부 페이지의 데이터만 로드</p>

<h4 id="restrepresentational-state-transfer">REST(Representational State Transfer)</h4>

<p>웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP메서드로 주고받은 웹 아키텍처</p>

<h5 id="rest-메서드">REST 메서드</h5>

<p>HTTP메서드 중 CRUD메서드만 사용 - POST(생성), GET(조회), PUT(수정), DELETE(삭제)</p>

<h4 id="데이터베이스-암호화-알고리즘">데이터베이스 암호화 알고리즘</h4>

<ul>
  <li>대칭 키 암호화 알고리즘: 암,복호화에 같은 암호 키를 쓰는 알고리즘</li>
  <li>비대칭 키 암호화 알고리즘: 공개키는 누구나 알 수 있지만, 비밀키는 키 소유자만 알 수 있게 사용하는 알고리즘</li>
  <li>해시 암호화 알고리즘: 해시값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘</li>
</ul>

<h4 id="중요-인터페이스-데이터의-암호화-전송을-보안-기술">중요 인터페이스 데이터의 암호화 전송을 보안 기술</h4>

<ul>
  <li>IPSec(IP Security): IP계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간(End Point) 구간에 보안 서비스를 제공하는 터널링 프로토콜</li>
  <li>SSL/TLS: 전송계층(4계층)과 응용계층(7계층) 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성, 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜</li>
  <li>S-HTTP(Secure Hupertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 주요 방법, 클라이언트와 서버 간에 전송되는 모든 메세지를 암호화하여 전송</li>
</ul>

<h3 id="인터페이스-구현-검증">인터페이스 구현 검증</h3>

<h4 id="인터페이스-구현-검증-도구">인터페이스 구현 검증 도구</h4>

<ul>
  <li>xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크</li>
  <li>STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크</li>
  <li>FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크</li>
  <li>NTAF: FitNesse(협업기능)+STAF(재사용, 확장성) 통합한 테스트 자동화 프레임워크</li>
  <li>Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크</li>
  <li>watir: 루비(Ruby)기반 웹 애플리케이션 테스트 프레임워크</li>
</ul>

<h4 id="인터페이스-감시-도구">인터페이스 감시 도구</h4>

<ul>
  <li>스카우터(SCOUTER): 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈 소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공</li>
  <li>제니퍼(Jennifer): 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계 동안 성능을 모니터링하고 분석해주는 APM 소프트웨어</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="인터페이스" /><category term="인터페이스구현" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 인터페이스 구현]]></summary></entry><entry><title type="html">CH04. 통합 구현</title><link href="http://localhost:4000/infoprocessing/post71/" rel="alternate" type="text/html" title="CH04. 통합 구현" /><published>2023-02-25T00:00:00+09:00</published><updated>2023-02-25T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post71</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post71/"><![CDATA[<h3 id="연계-요구사항-분석">연계 요구사항 분석</h3>

<h4 id="연계-요구사항-분석-1">연계 요구사항 분석</h4>

<p>서로 다른 두 시스템 · 장치 · 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과정</p>

<h4 id="연계-요구사항-분석-참고문서">연계 요구사항 분석 참고문서</h4>

<ul>
  <li>개체(Entitiy) 정의서: 데이터베이스 개념 모델링 단계에서 도출한 개체의 타입과 관련 속성, 식별자 등의 정보를 개괄적으로 명세화한 정의서</li>
  <li>테이블(Table) 정의서: 논리 및 물리 모델링 과정 설계 산출물</li>
  <li>인터페이스 명세서: 인터페이스 정의서에 작성한항목을 자세히 작성한 것</li>
</ul>

<h3 id="연계-메커니즘-구성">연계 메커니즘 구성</h3>

<h4 id="연계-메커니즘">연계 메커니즘</h4>

<p>응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘</p>

<ul>
  <li>기능: 데이터를 생성하여 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성</li>
</ul>

<h4 id="주요-연계-기술">주요 연계 기술</h4>

<ul>
  <li>직접 연계
    <ul>
      <li>DB 링크: 데이터베이스에서 제공하는 DB링크 객체를 이용</li>
      <li>DB 연결: 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB커넥션 풀을 생성하고 연계 프로그램에서 해당 DB커넥션 풀 명을 이용하여 연결</li>
      <li>API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램</li>
      <li>JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결</li>
      <li>하이퍼 링크: 현재 페이지에서 다른 부분으로 가거나 전혀 다른 페이지로 이동하게 해주는 속성</li>
    </ul>
  </li>
  <li>간접 연계
    <ul>
      <li>연계 솔루션(EAI): 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션</li>
      <li>Web Service/ESB: 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계</li>
      <li>소켓(Socket): 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신</li>
    </ul>
  </li>
</ul>

<h3 id="내외부-연계-모듈-구현">내외부 연계 모듈 구현</h3>

<h4 id="eaienterprise-application-intergration">EAI(Enterprise Application Intergration)</h4>

<p>기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계 통합이 가능하도록 해주는 솔루션</p>

<ul>
  <li>미들웨어를 이용하여 비즈니스 로직을 중심으로 기업 내 애플리케이션을 통합 연계</li>
</ul>

<h4 id="eai-구성요소">EAI 구성요소</h4>

<ul>
  <li>EAI 플랫폼: 이기종 시스템 간 애플리케이션 상호 운영</li>
  <li>어댑터: 다양한 애플리케이션을 연결하는 EAI의 핵심 장치로 데이터 입출력 도구</li>
  <li>브로커: 데이터 포맷과 코드를 변환하는 솔루션</li>
  <li>메시지 큐: 비동기 메세지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술</li>
  <li>비지니스 워크플로우: 미리 정의된 기업의 비즈니스 workflow에 따라 업무를 처리하는 기능</li>
</ul>

<h4 id="eai-구축-유형">EAI 구축 유형</h4>

<ul>
  <li>포인트 투 포인트(Point-to-point): 가장 기초적인 애플리케이션 통합방법. 1:1 단순 통합방법</li>
  <li>허브 앤 스포크(Hub &amp; Spoke): 단일한 접점의 허브 시스템을 통하여 데이터를 젆송하는 중앙 집중식 방식</li>
  <li>메시지 버스(Message Bus): 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식</li>
  <li>하이브리드(Hybrid): 그룹 내는 허브앤 스포크 방식을 사용, 그룹 간에는 메시지 버스 방식을 사용하는 통합 방식</li>
</ul>

<h4 id="esbenterprise-service-bus">ESB(Enterprise Service Bus)</h4>

<p>기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처. 느슨한 결합 방식 지원(서비스 변경이 있어도 연결된 다른 서비스에 영향이 없음)</p>

<ul>
  <li>미들웨어를 이용하여 서비스 중심으로 서비스를 지원하기 위한 관련시스템과 유기적 연계</li>
</ul>

<h4 id="esb-구축-유형">ESB 구축 유형</h4>

<p>버스 방식의 분산형 토폴로지 구성</p>

<h4 id="웹-서비스web-service">웹 서비스(Web Service)</h4>

<p>넽워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술. 서비스 지향 아키텍처</p>

<h4 id="웹-서비스-유형">웹 서비스 유형</h4>

<ul>
  <li>SOAP(Simple Objet Access Protocol): HTTP, HTTPS, SMTP등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜</li>
  <li>WSDL(Web Service Description Language): 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어</li>
  <li>UDDI(Universal Description, Discovery and Intergration): 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트</li>
</ul>

<h4 id="ipcinter-process-communication">IPC(Inter-Process Communication)</h4>

<p>운영체제에서 프로세스 간 서로 데이터를 주고받기 위한 통신 기술</p>

<h4 id="연계-테스트">연계 테스트</h4>

<p>송신 시스템과 수신 시스템을 연계하였을 경우 데이터의 정합성과 데이터 전송 여부에 대한 테스트</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="통합" /><category term="통합구현" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 통합 구현]]></summary></entry><entry><title type="html">CH02. 화면 설계</title><link href="http://localhost:4000/infoprocessing/post69/" rel="alternate" type="text/html" title="CH02. 화면 설계" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post69</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post69/"><![CDATA[<h3 id="uiuser-interface">UI(User Interface)</h3>

<p>사용자와 시스템 사이에서 의사소통 할 수 있도록 고안된 물리적, 가상의 매개체</p>

<h4 id="ui유형">UI유형</h4>

<ul>
  <li>CLI(Command Line Interface): 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스</li>
  <li>GUI(Graphical User Interface): 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용한 사용자 인터페이스</li>
  <li>NUI(Natural User Interface): 신체 부위를 이용하는 사용자 인터페이스</li>
  <li>OUI(Organic User Interface): 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스</li>
</ul>

<h4 id="ui-설계-원칙">UI 설계 원칙</h4>

<ul>
  <li>직관성: 누구나 쉽게 이해하고, 쉽게 사용할 수 있어야함</li>
  <li>유효성: 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작</li>
  <li>학습성: 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작</li>
  <li>유연성: 사용자의 요구사항을 최대한 수용하고, 실수를 방지할 수 있도록 제작</li>
</ul>

<h4 id="ui-설계-지침">UI 설계 지침</h4>

<ul>
  <li>사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결</li>
</ul>

<h4 id="ui-품질-요구사항isoiec-9126-기반">UI 품질 요구사항(ISO/IEC 9126 기반)</h4>

<ul>
  <li>기능성: 실제 수행 결과와 품질 요구사항과의 차이를 분석, 시스템 동작을 관찰하기 위한 품질 기준
    <ul>
      <li>적절성, 정밀성, 상호 운용성, 보안성, 호환성</li>
    </ul>
  </li>
  <li>신뢰성: 시스템이 일정한 시간 또는 작동되는 시간동안 의도하는 기능을 수행함을 보증하는 품질 기준
    <ul>
      <li>성숙성, 고장 허용성, 회복성</li>
    </ul>
  </li>
  <li>사용성: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준
    <ul>
      <li>이해성, 학습성, 운용성</li>
    </ul>
  </li>
  <li>효율성: 할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준
    <ul>
      <li>시간 효율성, 자원 효율성</li>
    </ul>
  </li>
  <li>유지보수성: 요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준
    <ul>
      <li>분석성, 변경성, 안정성, 시험성</li>
    </ul>
  </li>
  <li>이식성: 다른 플랫폼에서도 추가 작업 없이 얼마나 쉽게 적용 가능한가에 대한 품질 기준
    <ul>
      <li>적용성, 설치성, 대체성</li>
    </ul>
  </li>
</ul>

<h4 id="ui-표준">UI 표준</h4>

<ul>
  <li>디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약</li>
</ul>

<h4 id="crudcreate-read-update-delete">CRUD(Create, Read, Update, Delete)</h4>

<ul>
  <li>컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능</li>
</ul>

<h4 id="ui-개발을-위한-주요-기법">UI 개발을 위한 주요 기법</h4>

<ul>
  <li>3C 분석: 고객(Customer), 자사(Company), 경쟁사(Competitor)를 비교하고 분석하여 자사를 어떻게 차별화해서 경쟁에서 이길 것인가를 분석하는 기법</li>
  <li>SWOT 분석: 기업의 내/외부 환경을 분석하여 Strength(강점), Weakness(약점), Opportunity(기회), Treat(위협) 요인을 규정하고 이를 토대로 경영 저냑을 수립하는 방법</li>
  <li>시나리오 플래닝: 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하여 불확실성을 제거하는 경영 전략 방법</li>
  <li>사용성 테스트: 사용자가 직접 제품을 사용하면서 시나리오에 맞춰 과제를 수행한 후 질문에 응답하는 테스트</li>
  <li>워크숍: 특정 문제나 과제에 대한 새로운 지식, 기술, 아이디어, 방법들을 서로 교환하고 검토하는 세미나</li>
</ul>

<h4 id="ui-화면-설계-구분">UI 화면 설계 구분</h4>

<ul>
  <li>와이어프레임: 화면 단위의 레이아웃을 설계하는 작업 (ppt, 키노트, 스케치, 일러스트)</li>
  <li>스토리보드: 서비스 구축을 위한 모든 정보(정책, 프로세스,와이어프레임, 기능 정의 등)가 담겨 있는 설계 산출물 (ppt, 키노트, 스케치)</li>
  <li>프로토타입: 정적인 화면(와이어프레임, 스토리보드)에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형. 전체적인 기능을 간략한 형태로 구현한 시제품 (HTML, CSS)</li>
</ul>

<h3 id="ui-설계">UI 설계</h3>

<h4 id="umlunified-modeling-language">UML(Unified Modeling Language)</h4>

<ul>
  <li>객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어</li>
</ul>

<h5 id="uml-특징">UML 특징</h5>

<ul>
  <li>가시화 언어, 구축 언어, 명세화 언어, 문서화 언어</li>
</ul>

<h5 id="uml-구성요소">UML 구성요소</h5>

<ul>
  <li>사물, 관계, 다이어그램</li>
</ul>

<h5 id="uml다이어그램">UML다이어그램</h5>

<ul>
  <li>구조적 다이어그램 / 정적 다이어그램
    <ul>
      <li>클래스(Class): 클래스의 속성 및 연산과 클래스간 정적인 관계를 표현</li>
      <li>객체(Object): 클래스에 속한 사물(객체 =인스턴스)를 특정 시점의 객체와 객체 사이의 관계로 표현</li>
      <li>컴포넌트(Component): 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계 표현</li>
      <li>배치(Deployment): 컴포넌트 사이의 종속성을 표현하고, 물리적 요소들의 위치를 표현</li>
      <li>복합체 구조(Composite Structure): 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현</li>
      <li>패키지(Package): 유스케이스, 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계</li>
    </ul>
  </li>
  <li>행위적 다이어그램 / 동적 다이어그램
    <ul>
      <li>유스케이스(Usecase): 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 곤점에서 표현</li>
      <li>시퀀스(Sequence): 객체 간 동적 상호 작용을 시간적 개념을 중심으로 메시지 흐름으로 표현</li>
      <li>커뮤니케이션(Communication): 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 객체 간의 연관까지 표현</li>
      <li>상태(State): 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현</li>
      <li>활동(Activity): 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현</li>
      <li>타이밍(Timing): 객체 상태 변화와 시간 제약을 명시적으로 표현</li>
    </ul>
  </li>
</ul>

<h4 id="ui-시나리오-문서의-작성요건">UI 시나리오 문서의 작성요건</h4>

<ul>
  <li>완전성, 일관성, 이해성, 가독성, 추적 용이성, 수정 용이성</li>
</ul>

<h4 id="ui-설계-도구의-유형">UI 설계 도구의 유형</h4>

<ul>
  <li>화면 설계 도구: 파워목업, 발사믹목업, 카카오 오븐</li>
  <li>프로토타이핑 도구: UX핀, 액슈어, 네이버 프로토나우</li>
  <li>UI 디자인 도구: 스케치, Adobe XD</li>
  <li>UI 디자인 산출물로 작업하는 프로토타이핑 도구: 인버전, 픽사에이트, 프레이머</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="화면" /><category term="화면설계" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 화면 설계]]></summary></entry><entry><title type="html">CH03. 데이터 입출력 구현</title><link href="http://localhost:4000/infoprocessing/post70/" rel="alternate" type="text/html" title="CH03. 데이터 입출력 구현" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post70</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post70/"><![CDATA[<h3 id="논리-데이터-저장소-확인">논리 데이터 저장소 확인</h3>

<h4 id="데이터-모델data-model">데이터 모델(Data Model)</h4>

<ul>
  <li>현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델</li>
</ul>

<h4 id="데이터-모델-절차">데이터 모델 절차</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">요구사항 분석</code> → <code class="language-plaintext highlighter-rouge">개념적 설계</code> → <code class="language-plaintext highlighter-rouge">논리적 설계</code> → <code class="language-plaintext highlighter-rouge">물리적 설계</code></li>
</ul>

<h4 id="논리-데이터-모델링">논리 데이터 모델링</h4>

<ul>
  <li>업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스</li>
</ul>

<h4 id="논리적-데이터-모델링-종류">논리적 데이터 모델링 종류</h4>

<ul>
  <li>관계 데이터 모델: 테이블 형태, 1:1, 1:N, N:M</li>
  <li>계층 데이터 모델: 트리 형태(상하 관계), 1:N</li>
  <li>네트워크 데이터 모델: 그래프 형태, N:M</li>
</ul>

<h4 id="관계-대수">관계 대수</h4>

<ul>
  <li>관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어</li>
</ul>

<h5 id="관계-대수-연산자-종류">관계 대수 연산자 종류</h5>

<ul>
  <li>일반 집합 연산자
    <ul>
      <li>합집합(Union): ∪</li>
      <li>교집합(Intersection): ∩</li>
      <li>차집합(Difference): －</li>
      <li>카티션 프로덕트(CARTESIAN Product): ×</li>
    </ul>
  </li>
  <li>순수 관계 연산자
    <ul>
      <li>셀렉트(Select): σ</li>
      <li>프로젝트(Project): π</li>
      <li>조인(Join): ⋈</li>
      <li>디비전(Division): ÷</li>
    </ul>
  </li>
</ul>

<h4 id="관계-해석">관계 해석</h4>

<ul>
  <li>튜플 관계해석과 도메인 해석을 하는 비절차적 언어</li>
</ul>

<h4 id="논리-데이터-모델링-속성">논리 데이터 모델링 속성</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">개체(Entitiy)</code>, <code class="language-plaintext highlighter-rouge">속성(Attributes)</code>, <code class="language-plaintext highlighter-rouge">관계(Relationship)</code></li>
</ul>

<h4 id="개체-관계e-r-모델">개체-관계(E-R) 모델</h4>

<ul>
  <li>데이터와 그들간의 관계를 사람이 이해할 수 있는 형태로 표현한 모델</li>
</ul>

<h4 id="정규화">정규화</h4>

<ul>
  <li>데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정</li>
</ul>

<h5 id="이상현상anomaly">이상현상(Anomaly)</h5>

<ul>
  <li>데이터의 중복성으로 인해 릴레이션을 조작할때 발생하는 비합리적 현상
    <ul>
      <li>삽입이상: 불필요한 세부정보 입력하는 경우</li>
      <li>삭제이상: 원치 않는 다른 정보가 같이 삭제되는 경우</li>
      <li>갱신이상: 특정부분만 수정되어 중복된 값이 모순을 일으키는 경우</li>
    </ul>
  </li>
</ul>

<h5 id="정규화-단계">정규화 단계</h5>

<ul>
  <li>1정규형(1NF): 도메인이 원자값으로 구성</li>
  <li>2정규형(2NF): 부분함수 종속제거 (완전 함수적 종속을 만족)</li>
  <li>3정규형(3NF): 이행함수 종속제거</li>
  <li>보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거</li>
  <li>4정규형(4NF): 다중 값 종속제거</li>
  <li>5정규형(5NF): 조인 종속 제거</li>
</ul>

<h5 id="반정규화de-nomalization">반정규화(De-Nomalization)</h5>

<ul>
  <li>정규화된 개체, 속성, 관계에 대해 성능향상과 개발운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법</li>
</ul>

<h3 id="물리-데이터-저장소-설계">물리 데이터 저장소 설계</h3>

<h4 id="참조무결성-제약조건">참조무결성 제약조건</h4>

<ul>
  <li>릴레이션과 릴레이션 사이에 대한 참조의 일관성을 보장하기 위한 조건
    <ul>
      <li>제한(Restricted): 다른테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션</li>
      <li>연쇄(Cascade): 참조하는 테이블까지 연쇄적으로 제거하는 옵션</li>
      <li>널값(Set Null): 참조되는 리레이션에서 튜플을 삭제하고, 참조하는 튜플들의 외래값에 NULL값을 넣는 옶션. / 만약, NOT NULL 명시시 삭제 연산 거절됨.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>ALTER TABLE 테이블 ADD
FOREIGN KEY (외래키)
REFERENCES 참조테이블(기본키)
ON DELETE [ RESTRICT | CASCADE | SET NULL ] ;
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="인덱스index">인덱스(Index)</h4>

<ul>
  <li>데이터 레코드를 빠르게 접근하기 위해 ‘키값, 포인터’ 쌍으로 구성되는 데이터 구조
    <ul>
      <li>클러스터드 인덱스: 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식</li>
      <li>넌클러스터드 인덱스: 인덱스의 키값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식</li>
    </ul>
  </li>
</ul>

<h4 id="뷰view">뷰(View)</h4>

<ul>
  <li>접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로 구성된 가상 테이블</li>
</ul>

<h4 id="클러스터cluster">클러스터(Cluster)</h4>

<ul>
  <li>데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법. 클러스터의 분포도가 넓을수록 유리하다</li>
</ul>

<h4 id="파티션partition">파티션(Partition)</h4>

<ul>
  <li>대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
    <ul>
      <li>범위분할(Range Partitioning): 지정한 열의 값을 기준으로 분할함</li>
      <li>해시분할(Hash Partitioning): 해시 함수를 적용한 결과 값에 따라 데이터를 분할.</li>
      <li>리스트분할(List Partitioning): 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 분할 기법</li>
      <li>조합분할(Composite Partitioning): 범위,해시,리스트 분할 중 2개의이상의 파티셔닝을 결합하는 방식. 파티션이 너무 클떄 사용</li>
    </ul>
  </li>
</ul>

<h5 id="파티션-장점">파티션 장점</h5>

<ul>
  <li>성능 향상, 가용성 향상, 백업 가능, 경합 감소</li>
</ul>

<h3 id="데이터베이스-기초-활용하기">데이터베이스 기초 활용하기</h3>

<h4 id="데이터베이스database">데이터베이스(Database)</h4>

<ul>
  <li>다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합</li>
</ul>

<h4 id="데이터베이스-정의">데이터베이스 정의</h4>

<ul>
  <li>통합된 데이터: 자료의 중복을 배제한 데이터의 모임</li>
  <li>저장된 데이터: 저장 매체에 저장된 데이터</li>
  <li>운영 데이터: 조직의 업무를 수행하는 데 필요한 데이터</li>
  <li>공용 데이터: 여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터</li>
</ul>

<h4 id="데이터베이스-특성">데이터베이스 특성</h4>

<ul>
  <li>실시간 접근성: 쿼리에 대하여 실시간 응답이 가능해야 함</li>
  <li>계속적인 변화: 새로운 데이터의 삽입, 삭제 갱신 으로 항상 최신의 데이터를 유지</li>
  <li>동시공용: 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야함</li>
  <li>내용참조: 사용자가 요구하는 데이터 내용으로 데이터를 찾음</li>
</ul>

<h4 id="데이터베이스-종류">데이터베이스 종류</h4>

<ul>
  <li>파일 시스템(File System): 파일에 이름을 부여하고 저장이나 검색을 위해 논리적으로 그것들을 어디에 위치시켜야 하는지 등을 정의한 뒤 관리하는 데이터베이스 전 단계의 데이터 관리 방식</li>
  <li>관계형 데이터베이스 시스템(RDBMS): 관계형 모델을 기반
    <ul>
      <li>종류: Oracle, SQL Server, MySQL, MariaDB 등</li>
    </ul>
  </li>
  <li>계층형 데이터베이스 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화화여 관리
    <ul>
      <li>종류: IMS, System 2000 등</li>
    </ul>
  </li>
  <li>네트워크 데이터베이스 관리시스템(NDBMS): 데이터를 네트워크상의 망상 형태로 표현한 데이터 모델
    <ul>
      <li>종류: IDS, IDMS 등</li>
    </ul>
  </li>
</ul>

<h4 id="dbmsdatabase-management-system">DBMS(Database Management System)</h4>

<ul>
  <li>데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어</li>
</ul>

<h5 id="dmbs-유형">DMBS 유형</h5>

<ul>
  <li>키-값(Key-Value) DBMS: Unique 한 키에 하나의 값을 가지고 있는 형태</li>
  <li>컬럼 기반 데이터 저장(Column Family Data Store) DMBS: Key안에(Column, Value) 조합으로 된 여러개의 필드를 갖는 DBMS</li>
  <li>문서 저장(Document Store) DBMS: 값(Value)의 데이터 타입이 문서(Documnet)라는 타입을 사용하는 DBMS</li>
  <li>그래프(Graph) DBMS: 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS</li>
</ul>

<h5 id="dbms-특징">DBMS 특징</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">무결성</code>, <code class="language-plaintext highlighter-rouge">일관성</code>, <code class="language-plaintext highlighter-rouge">회복성</code>, <code class="language-plaintext highlighter-rouge">보안성</code>, <code class="language-plaintext highlighter-rouge">효율성</code></li>
</ul>

<h4 id="빅-테이터big-data">빅 테이터(Big Data)</h4>

<ul>
  <li>시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 수십 페타바이트(PB) 크기의 비정형 데이터</li>
</ul>

<h5 id="빅데이터-특성">빅데이터 특성</h5>

<ul>
  <li>데이터의 양, 데이터의 다양성, 데이터의 속도</li>
</ul>

<h5 id="빅데이터-수집-저장-처리-기술">빅데이터 수집, 저장, 처리 기술</h5>

<ul>
  <li>비정형/반정형 데이터 수집: 내/외부 정제되지 않은 데이터를 확보하여 수집 및 전송하는 기술</li>
  <li>정형 데이터 수집: 내/외부 정제된 대용량 데이터의 수집 및 전송 기술</li>
  <li>분산데이터 저장/처리: 대용량 파일의 효과적인 부산 저장 및 분산 처리 기술</li>
  <li>분산데이터 베이스: HDFS 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트 가능
    <ul>
      <li>HDFS:대용량 데이터의 집합을 처리하는 응용 프로그램에 적합하도록 설계된 하둡 분산 파일 시스템</li>
    </ul>
  </li>
</ul>

<h4 id="nosqlnot-only-sql">NoSQL(Not Only SQL)</h4>

<ul>
  <li>데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 DBMS</li>
</ul>

<h5 id="nosql-특성">NoSQL 특성</h5>

<ul>
  <li>Basically Available: 언제든지 데이터 접근 할 수 있는 속성</li>
  <li>Soft-State: 외부에서 전송된 정보를 통해 결정되는 속성</li>
  <li>Eventually Consistency: 이관성이 유지되는 속성</li>
</ul>

<h5 id="nosql-유형">NoSQL 유형</h5>

<ul>
  <li>Key-Value Store: Unique 한 키에 하나의 값을 가지고 있는 형태</li>
  <li>Column Family Data Store : Key안에(Column, Value) 조합으로 된 여러개의 필드를 갖는 DB</li>
  <li>Document Store: 값(Value)의 데이터 타입이 문서(Documnet)라는 타입을 사용하는 DB</li>
  <li>Graph DBMS: 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS’
    <ul>
      <li>시맨틱 웹: 온톨로지를 활용하여 서비스를 기술하고, 온톨로지의 의미적 상호 운용성을 이용해서 서비스 검색, 조합, 중재 기능을 자동화하는 웹</li>
      <li>온톨로지: 실세계에 존재하는 모든 개념들과 개념들의 속성, 그리고 개념들간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 지식베이스</li>
    </ul>
  </li>
</ul>

<h4 id="데이터-마이닝data-minning">데이터 마이닝(Data Minning)</h4>

<ul>
  <li>대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술</li>
</ul>

<h5 id="데이터-마이닝-절차">데이터 마이닝 절차</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">목적 설정</code> → <code class="language-plaintext highlighter-rouge">데이터 준비</code> → <code class="language-plaintext highlighter-rouge">가공</code> → <code class="language-plaintext highlighter-rouge">마이닝 기법 적용</code> → <code class="language-plaintext highlighter-rouge">정보 검증</code></li>
</ul>

<h5 id="데이터-마이닝-주요-기법">데이터 마이닝 주요 기법</h5>

<ul>
  <li>분류 규칙: 과거 데이터로를 토대로 새로운 레코드의 결과 값을 예측하는 기법</li>
  <li>연과 규칙: 데이터 안에 항목들 간의 종속관계를 찾아내는 기법</li>
  <li>연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법</li>
  <li>데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="데이터" /><category term="데이터입출력구현" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 데이터 입출력 구현]]></summary></entry><entry><title type="html">CH01. 소프트웨어 개발 방법론</title><link href="http://localhost:4000/infoprocessing/post68/" rel="alternate" type="text/html" title="CH01. 소프트웨어 개발 방법론" /><published>2023-01-29T00:00:00+09:00</published><updated>2023-01-29T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post68</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post68/"><![CDATA[<h3 id="소프트웨어-생명주기sdlc">소프트웨어 생명주기(SDLC)</h3>

<p>시스템의 요구분석 부터 유지보수까지 전 공정을 체계화 한 절차</p>

<ul>
  <li>폭포수 모델: 가장 오래된 모델, 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어감</li>
  <li>프로토타이핑 모델: 주요기능을 프로토타입으로 구현해, 고객의 피드백을 반영하여 S/W 만듦</li>
  <li>나선형 모델: 위험을 최소화하기 위해 점진적으로 시스템 개발</li>
  <li>반복적 모델: 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발</li>
</ul>

<h3 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h3>

<p>소프트웨어 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정을 형상화한 방법론</p>

<ul>
  <li>구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 방법론
    <ul>
      <li>나씨-슈나이더만 차트: 논리의 기술에 중점을 둔 도형식 표현방법</li>
    </ul>
  </li>
  <li>정보공학 방법론: 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론</li>
  <li>객체 지향 방법론: ‘객체’라는 기본 단위로 시스템을 분석 및 설계하는 방법론</li>
  <li>컴포넌트 기반 방법론 (CBD): 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론</li>
  <li>애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적인 시스템 개발할 수 있는 신속 적응적 개량 개발 방법론</li>
  <li>제품 계열 방법론: 특정 제품에 적용하고 싶은 공통된 기능을 정의해 개발하는 방법론, 임베디드 S/W작성에 유용</li>
</ul>

<h4 id="애자일agile-방법론">애자일(Agile) 방법론</h4>

<ul>
  <li>XP(eXtreme Programming): 의사소통 개선과 즉각적 피드백으로 스프트웨어 품질을 높이기 위한 방법론
    <ul>
      <li>XP 5가지 가치: 용기, 단순성, 의사소통, 피드백, 존중</li>
    </ul>
  </li>
  <li>스크럼(Scrum): 매일 정해진 시간, 장소에서 짤은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론</li>
  <li>린(Lean): 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    <ul>
      <li>Lean 7가지 가치: 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화</li>
    </ul>
  </li>
</ul>

<h4 id="객체-지향-분석-방법론">객체 지향 분석 방법론</h4>

<p>객체 지향 분석(OOA) : 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의</p>

<ul>
  <li>OOSE(Object Oriented Software Engineering): 유스케이스를 모든 모델의 근간으로 활용되는 방법론, 야콥슨 만듦</li>
  <li>OMT(Object Modeling Technology): 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링, 럼바우 만듦
    <ul>
      <li>분석 절차: 객체 모델링 → 동적 모델링 → 기능 모델링</li>
      <li>객체 모델링: 객체들 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링, 객체 다이어그램 활용</li>
      <li>동적 모델링: 시간의 흐름에 따라 객체들의 동적인 행위를 표현하는 모델링, 상태 다이어그램 활용</li>
      <li>기능 모델링: 프로세스들의 자료 흐름을 중심으로 처리 과정 표현하는 모델링, 자료 흐름도(DFD) 활용</li>
    </ul>
  </li>
</ul>

<h3 id="비용-산정-모형-분류">비용 산정 모형 분류</h3>

<ul>
  <li>하향식 산정방법: 경험이 많은 전문가에게 비용산정 의뢰 또는 전문가와 조정자를 통해 비용산정
    <ul>
      <li>전문가 판단</li>
      <li>델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법</li>
    </ul>
  </li>
  <li>상향식 산정방법: 세부적인 요구사항과 기능에 따라 필요한 비용 산정
    <ul>
      <li>코드 라인 수(LoC: Lines of Code): 원시 코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용산정</li>
      <li>Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 비용산정</li>
      <li>COCOMO 모형: 보헴이 제안한 모형으로 프로그램의 규모에 따라 비용산정
        <ul>
          <li>조직형(Organic Mode): 5만(50KDSI)라인 이하</li>
          <li>반 분리형(Semi-Detached Mode): 30만(300KDSI)라인 이하</li>
          <li>임베디드형(Embedded Mode): 30만(300KDSI)라인 이상</li>
        </ul>
      </li>
      <li>푸트남(Putnam) 모형: 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식</li>
      <li>기능점수(FP) 모형: 소프트웨어 기능을 증대시키는 요인별로 가중치를 부여하여 비용산정</li>
    </ul>
  </li>
</ul>

<h4 id="비용-산정-자동화-추정-도구">비용 산정 자동화 추정 도구</h4>

<ul>
  <li>SLIM: Rayleigh-Norden곡선과 Putnam예측 모델을 기초로 하여 개발된 자동화 추정 도구</li>
  <li>ESTIMACS: 다양한 프로젝트와 개인별 요소를 수용하도록 FP모형을 기초로 하여 개발된 자동화 추정 도구</li>
</ul>

<h3 id="일정관리-모델">일정관리 모델</h3>

<p>프로젝트가 일정 기한 내에 완료될 수 있도록 관리하는 모델</p>

<ul>
  <li>주 공정법(CPM): 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법
    <ul>
      <li>주 공정(Critical Path: 임계 경로): 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경로</li>
    </ul>
  </li>
  <li>PERT: 일의 순서를 계획적으로 정리하기 위한 수렴 기법. 비관치, 중간치, 낙관치 이용</li>
  <li>중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="소프트웨어" /><category term="소프트웨어개발방법론" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 소프트웨어 개발 방법론]]></summary></entry><entry><title type="html">React Router에서 render와 component 차이</title><link href="http://localhost:4000/react/post66/" rel="alternate" type="text/html" title="React Router에서 render와 component 차이" /><published>2022-12-21T00:00:00+09:00</published><updated>2022-12-21T00:00:00+09:00</updated><id>http://localhost:4000/react/post66</id><content type="html" xml:base="http://localhost:4000/react/post66/"><![CDATA[<p>React에서는 Route를 사용하여 라우팅을 하는 것이 가능합니다. react-router에서 컴포넌트를 렌더링 하는 방법은 3가지가 있습니다.</p>

<h3 id="자식으로-렌더링-하기">자식으로 렌더링 하기</h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserRouter</span><span class="p">,</span> <span class="nx">Link</span><span class="p">,</span> <span class="nx">Route</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-router-dom</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">PageOne</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/PageOne</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">PageTwo</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/PageTwo</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/pageone"</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">PageOne</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Route</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/pagetwo"</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nc">PageTwo</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nc">Route</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="component-사용">component 사용</h3>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserRouter</span><span class="p">,</span> <span class="nx">Route</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-router-dom</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">PageOne</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/PageOne</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
       <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/pageone"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">PageOne</span><span class="si">}</span><span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;Route&gt;</code>의 자식으로 렌더링 하거나 <code class="language-plaintext highlighter-rouge">&lt;Route component&gt;</code>를 활용하여 렌더링 하는 방법 모두 간편하게 이용할 수 있지만 두 방법 모두 props를 사용할 수 없다는 단점이 있고, component를 사용하는 경우는 React.createElement 사용해서 새로운 요소를 계속 만들기 때문에 비효율적입니다. 그래서 최종적으로 가장 권장되는 방법이 바로 아래의 <code class="language-plaintext highlighter-rouge">render</code>를 사용하는 방법이라고 할 수 있습니다.</p>

<h3 id="render-사용">render 사용</h3>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">BrowserRouter</span><span class="p">,</span> <span class="nx">Link</span><span class="p">,</span> <span class="nx">Route</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-router-dom</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">PageOne</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/PageOne</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">PageTwo</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./components/PageTwo</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
       <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/pageone"</span> <span class="na">render</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nc">PageOne</span> <span class="p">/&gt;</span><span class="si">}</span> <span class="p">/&gt;</span>
       <span class="p">&lt;</span><span class="nc">Route</span> <span class="na">path</span><span class="p">=</span><span class="s">"/pagetwo"</span> <span class="na">render</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nc">PageTwo</span> <span class="p">/&gt;</span><span class="si">}</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">BrowserRouter</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 사용하면 불필요한 컴포넌트 재마운트 없이 쉽게 렌더링 할 수 있습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="p">&lt;</span><span class="nc">Route</span> 
  <span class="na">path</span><span class="p">=</span><span class="s">"/pageone"</span> 
  <span class="na">render</span><span class="p">=</span><span class="si">{</span><span class="nx">props</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nc">PageOne</span> <span class="si">{</span><span class="p">...</span><span class="nx">props</span><span class="si">}</span> <span class="na">isAuthed</span><span class="p">=</span><span class="s">"{true}"</span> <span class="p">/&gt;</span><span class="si">}</span> <span class="p">/&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>props를 전달하고 싶은 경우에는 위 방식으로 사용할 수 있습니다 :)</p>

<h3 id="️-참고-사이트">✔️ 참고 사이트</h3>

<ul>
  <li><a href="https://nyang-in.tistory.com/228">https://nyang-in.tistory.com/228</a></li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="React" /><category term="리액트" /><category term="router" /><category term="라우터" /><category term="render" /><category term="component" /><summary type="html"><![CDATA[render / component]]></summary></entry></feed>