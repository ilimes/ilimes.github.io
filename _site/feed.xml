<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-03T23:52:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ilimes</title><subtitle>**공부하고 기록하는** 블로그</subtitle><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><entry><title type="html">NVM default 노드 버전 변경 하는 방법</title><link href="http://localhost:4000/setting/post84/" rel="alternate" type="text/html" title="NVM default 노드 버전 변경 하는 방법" /><published>2023-10-31T00:00:00+09:00</published><updated>2023-10-31T00:00:00+09:00</updated><id>http://localhost:4000/setting/post84</id><content type="html" xml:base="http://localhost:4000/setting/post84/"><![CDATA[<p>오늘은 nvm에서 기본(default) 노드 버전을 변경하는 방법을 간단하게 소개해드리도록 하겠습니다 :)</p>

<h3 id="nvm-list-확인">nvm list 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>nvm list
</pre></td></tr></tbody></table></code></pre></div></div>

<p>우선 nvm list 명령어를 입력하여 현재 default 노드 버전이 무엇인지 확인합니다.</p>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/c9161fa3-eac9-4f3f-8360-044d20ea566a" alt="image" /></p>

<p>현재 저의 default 노드 버전은 v14.15.5로 되어있습니다. v18.17.0 으로 변경해보도록 하겠습니다.</p>

<h3 id="default-버전-변경">default 버전 변경</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>nvm <span class="nb">alias </span>default 18.17.0
</pre></td></tr></tbody></table></code></pre></div></div>

<p>default 버전을 변경하고자 하는 경우에는 <code class="language-plaintext highlighter-rouge">alias default</code> 명령어를 입력하면 됩니다.</p>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/0fb73df2-6cd4-4124-84b5-c89ae2c1673e" alt="image" /></p>

<p>위처럼 정상적으로 default 버전이 변경된 것을 확인하실 수 있습니다.<br />
앞으로 터미널을 재시작하더라도 버전이 변경되지 않습니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Setting" /><category term="NVM" /><category term="default" /><category term="nvm default" /><category term="node.js" /><category term="node" /><summary type="html"><![CDATA[NVM default node version setting]]></summary></entry><entry><title type="html">MySQL/MariaDB WITH RECURSIVE 재귀 쿼리</title><link href="http://localhost:4000/mariadb/post83/" rel="alternate" type="text/html" title="MySQL/MariaDB WITH RECURSIVE 재귀 쿼리" /><published>2023-10-29T00:00:00+09:00</published><updated>2023-10-29T00:00:00+09:00</updated><id>http://localhost:4000/mariadb/post83</id><content type="html" xml:base="http://localhost:4000/mariadb/post83/"><![CDATA[<p>오늘은 프로그래머스 문제를 풀다가 처음 알게된 문법이 있어서 공유해보고자 합니다. 바로 <code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 라는 재귀 쿼리입니다.</p>

<h3 id="with-recursive">WITH RECURSIVE</h3>

<p><code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 의 기본 구조는 아래와 같습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="err">테이블명</span> <span class="k">AS</span><span class="p">(</span>
  <span class="k">SELECT</span> <span class="err">초기값</span> <span class="k">AS</span> <span class="err">컬럼별명</span><span class="mi">1</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="k">SELECT</span> <span class="err">컬럼별명</span><span class="mi">1</span> <span class="err">계산식</span> <span class="k">FROM</span> <span class="err">테이블명</span> <span class="k">WHERE</span> <span class="err">제어문</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 는 아래와 같이 WITH와 RECURSIVE로 나눌 수 있습니다.</p>

<h3 id="with">WITH</h3>

<ul>
  <li><strong>CTE</strong>(common table expression)을 생성하는 문법</li>
  <li><strong>CTE</strong>란 해당 SQL문 내에서만 존재하는, 즉 메모리 상에 가상의 테이블을 저장할 때 사용된다.</li>
</ul>

<h3 id="recursive">RECURSIVE</h3>

<ul>
  <li>서브쿼리에서 스스로를 참조하는 <strong>CTE</strong></li>
  <li>가상의 테이블을 생성하면서 자신의 값을 참조하여 결정할 때 사용</li>
</ul>

<h3 id="예시">예시</h3>

<p>1부터 5까지 출력하는 예시입니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="n">d</span> 
<span class="k">AS</span> <span class="p">(</span>
    <span class="k">select</span> <span class="mi">1</span> <span class="k">as</span> <span class="n">n</span>
    <span class="k">union</span> <span class="k">all</span>
    <span class="k">select</span>
        <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">from</span> <span class="n">d</span>
    <span class="k">where</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="p">)</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">d</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="출력-결과">출력 결과</h4>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/709c02cc-9718-4d98-a498-6892f8949dc0" alt="image" /></p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="MariaDB" /><category term="데이터베이스" /><category term="DB" /><category term="MariaDB" /><category term="WITH RECURSIVE" /><summary type="html"><![CDATA[MySQL/MariaDB WITH RECURSIVE]]></summary></entry><entry><title type="html">React Native - Sticky Header (헤더 고정)</title><link href="http://localhost:4000/reactnative/post82/" rel="alternate" type="text/html" title="React Native - Sticky Header (헤더 고정)" /><published>2023-10-04T00:00:00+09:00</published><updated>2023-10-04T00:00:00+09:00</updated><id>http://localhost:4000/reactnative/post82</id><content type="html" xml:base="http://localhost:4000/reactnative/post82/"><![CDATA[<h3 id="sticky-header-사용법">Sticky Header 사용법</h3>

<p>앱을 만들다보면 스크롤을 내릴때 헤더를 고정하는 Sticky Header를 구현하고 싶을 때가 있는데요. React Native ScrollView에서는 간단히 구현할 수 있습니다.</p>

<p>아래와 같이 스크롤 뷰 속성에 <code class="language-plaintext highlighter-rouge">stickyHeaderIndices</code> 를 추가하면 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="p">&lt;</span><span class="nc">ScrollView</span> 
    <span class="na">stickyHeaderIndices</span><span class="p">=</span><span class="si">{</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span> <span class="c1">// 숫자: sticky 속성을 사용할 컴포넌트의 위치</span>
<span class="p">&gt;</span> 
   ...
<span class="p">&lt;/</span><span class="nc">ScrollView</span><span class="p">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>예를 들어 1번째 컴포넌트를 고정하고 싶다면 위와 같이 배열 안에 숫자를 <code class="language-plaintext highlighter-rouge">0</code>으로 설정해주면 됩니다.<br />
만약 <code class="language-plaintext highlighter-rouge">1</code>로 하면 2번째 컴포넌트가 고정됩니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="ReactNative" /><category term="리액트네이티브" /><category term="React" /><category term="RN" /><category term="Sticky" /><category term="stickyHeaderIndices" /><category term="scrollview" /><summary type="html"><![CDATA[리액트 네이티브 Sticky]]></summary></entry><entry><title type="html">Git - fatal: Unable to create ‘~~/.git/index.lock’: File exists. 에러 해결</title><link href="http://localhost:4000/git/post81/" rel="alternate" type="text/html" title="Git - fatal: Unable to create ‘~~/.git/index.lock’: File exists. 에러 해결" /><published>2023-10-04T00:00:00+09:00</published><updated>2023-10-04T00:00:00+09:00</updated><id>http://localhost:4000/git/post81</id><content type="html" xml:base="http://localhost:4000/git/post81/"><![CDATA[<h3 id="문제-상황">문제 상황</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>git add <span class="nb">.</span>
fatal: Unable to create <span class="s1">'디렉토리/.git/index.lock'</span>: File exists.

Another git process seems to be running <span class="k">in </span>this repository, e.g.
an editor opened by <span class="s1">'git commit'</span><span class="nb">.</span> Please make sure all processes
are terminated <span class="k">then </span>try again. If it still fails, a git process
may have crashed <span class="k">in </span>this repository earlier:
remove the file manually to <span class="k">continue</span><span class="nb">.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>git add .로 파일을 올리고자 할 때 갑자기 위와 같은 에러가 나는 경우가 있습니다.
이유는 <code class="language-plaintext highlighter-rouge">.git 디렉토리에 index.lock 파일이 존재하기 때문</code> 입니다.</p>

<h3 id="해결-방법">해결 방법</h3>

<p>해결 방법은 매우 간단합니다.</p>

<p>특정 Git 프로세스가 동작중일 때 다른 Git 프로세스가 실행되는 것을 막기 위해서 index.lock 이라는 파일이 생기는 것인데 의도해서 생성한 것이 아니라면 삭제해주면 됩니다. 폴더에서 직접 index.lock 파일을 삭제하거나, 아래 명령어를 입력하여 해결할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-f</span> .git/index.lock
</pre></td></tr></tbody></table></code></pre></div></div>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Git" /><category term="github" /><category term="Git" /><category term="깃" /><category term="에러해결" /><category term="fatal" /><summary type="html"><![CDATA[Git 에러 해결 방법]]></summary></entry><entry><title type="html">웹 브라우저 렌더링 종류와 차이점</title><link href="http://localhost:4000/web/post80/" rel="alternate" type="text/html" title="웹 브라우저 렌더링 종류와 차이점" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/web/post80</id><content type="html" xml:base="http://localhost:4000/web/post80/"><![CDATA[<p>렌더링이란 간단히 말하면 HTML, CSS, javaScript 등 개발자가 작성한 문서가 화면에 표시되는 것이라고 할 수 있는데요. 오늘은 웹 브라우저 렌더링의 종류에 대해서 알아보고, 각각 어떠한 장단점이 있는지 정리해보도록 하겠습니다 😊</p>

<h3 id="렌더링의-종류">렌더링의 종류</h3>

<p>렌더링의 종류는 크게 4가지로 구분할 수 있습니다.</p>

<hr />

<h4 id="서버-사이드-렌더링-ssr">서버 사이드 렌더링 (SSR)</h4>

<p>서버 사이드 렌더링이란 말 그대로 클라이언트가 요청하였을 때 <strong>서버측에서 렌더링</strong>을 해서 보내주는 것을 말합니다.</p>

<h5 id="장점">장점</h5>

<ul>
  <li>초기 로딩 속도가 빠르다.
    <ul>
      <li>해당 첫 페이지에 해당하는 문서만 브라우저에 전달하여 렌더링 하기 때문</li>
    </ul>
  </li>
  <li>자바스크립트 설정이 필요하지 않다.</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.
    <ul>
      <li>SEO란 웹을 크롤링하며 페이지에 컨텐츠 색인을 생성하는 과정</li>
    </ul>
  </li>
</ul>

<h5 id="단점">단점</h5>

<ul>
  <li>초기 로딩속도가 빠른만큼 TTV(Time To View)와 TTI(Time to Interact)간 시간 간격이 존재
    <ul>
      <li>TTV는 사용자가 웹사이트를 보는 것을 말하고, TTI는 클릭 이벤트와 같은 인터랙션이 가능한 상태</li>
    </ul>
  </li>
  <li>초기 로딩 이후에는 페이지 이동 속도가 다소 느릴 수 있다.
    <ul>
      <li>페이지 이동시마다 클라이언트가 서버에게 필요한 데이터를 요청하고, 서버가 응답해주는 방식이기 때문</li>
    </ul>
  </li>
  <li>매번 페이지가 새로고침 되어 사용자 경험이 떨어질 수 있다.</li>
</ul>

<hr />

<h4 id="클라이언트-사이드-렌더링-csr">클라이언트 사이드 렌더링 (CSR)</h4>

<p>클라이언트 사이드 렌더링은 서버 사이드 렌더링과 반대라고 할 수 있는데, 프로그래밍된 스크립트가 서버가 아닌 <strong>클라이언트(브라우저)</strong>에서 처리되는 것을 말합니다.</p>

<h5 id="장점-1">장점</h5>

<ul>
  <li>클라이언트에서 많은 것들이 이루어지기 때문에 초기 로딩이 느리지만, 로딩이 완료되고 나면 빠른 동작이 가능</li>
  <li>서버에 부하가 적음</li>
</ul>

<h5 id="단점-1">단점</h5>

<ul>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)에 대한 보완 작업 필요
    <ul>
      <li>검색 엔진 크롤러가 웹사이트에 대한 데이터를 제대로 수집하지 못하는 경우가 발생할 수 있습니다. SEO를 위해서 sitemap 문서 작성과 같은 과정이 필요할 수 있습니다.</li>
    </ul>
  </li>
  <li>보안에 취약</li>
</ul>

<hr />

<h4 id="정적-사이트-생성-ssg">정적 사이트 생성 (SSG)</h4>

<p>SSG란 Static Site Generation의 약자로 <strong>정적인 페이지</strong>를 생성하는 것을 말합니다.</p>

<h5 id="장점-2">장점</h5>

<ul>
  <li>초기 로딩이 빠르다</li>
  <li>자바스크립트 설정이 필요하지 않다.</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.</li>
  <li>보안이 좋다</li>
</ul>

<h5 id="단점-2">단점</h5>

<ul>
  <li>데이터가 정적이다
    <ul>
      <li>블로그와 같이 데이터가 잘 바뀌지 않는 사이트 같은 경우 사용하기 적합하지만, 변화가 자주 이뤄져야 하는 경우에는 적합하지 않음</li>
    </ul>
  </li>
  <li>사용자별로 달라지는 데이터 제공 어려움</li>
</ul>

<hr />

<h4 id="증분-정적-재생-isr">증분 정적 재생 (ISR)</h4>

<p>ISR이란 Incremental Static Regeneration의 약자로 SSG를 보완하기 위해 정적인 사이트를 서버 측에서 주기적으로 렌더링 하는 것을 말합니다.<br />
전체적인 원리는 SSG와 동일하고, 설정한 주기만큼 페이지를 계속 다시 만들어줍니다.</p>

<h5 id="장점-3">장점</h5>

<ul>
  <li>초기 로딩이 빠르다</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.</li>
  <li>보안이 좋다</li>
  <li>주기적으로 데이터가 업데이트 된다</li>
</ul>

<h5 id="단점-3">단점</h5>

<ul>
  <li>주기적인 변경이 가능하지만 실시간 데이터가 아니다</li>
  <li>사용자별로 달라지는 데이터 제공 어려움</li>
</ul>

<hr />

<p>오늘 이렇게 4가지 웹 브라우저 렌더링 방식에 대해서 알아보았는데요. 각각의 특징이 있기 때문에 상황에 맞게 잘 적용해야겠다는 생각이 들었습니다.</p>

<p>참고로 <code class="language-plaintext highlighter-rouge">Next.js</code> 같은 경우는 성능 좋은 강력한 웹앱을 만들기 위해서 두 개 이상의 렌더링 방법을 사용하는 하이브리드 방식을 지원하고 있습니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Web" /><category term="렌더링" /><category term="SSR" /><category term="CSR" /><category term="SSG" /><category term="ISR" /><summary type="html"><![CDATA[SSR, CSR, SSG, ISR에 대해서 알아보기]]></summary></entry><entry><title type="html">[Windows] 인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기</title><link href="http://localhost:4000/issue/post79/" rel="alternate" type="text/html" title="[Windows] 인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T00:00:00+09:00</updated><id>http://localhost:4000/issue/post79</id><content type="html" xml:base="http://localhost:4000/issue/post79/"><![CDATA[<p>최근 스프링부트 개발을 인텔리제이로 하고있는데, 맥과 윈도우를 번갈아가면서 사용하고 있습니다.<br />
맥에서는 별도로 무언가 설정하지 않아도 문제없이 한글로된 콘솔이 잘 찍혔는데, 윈도우에서는 인텔리제이에 별도로 설정을 해놓지 않으면 한글이 깨져서 나오더라고요.<br />
<br />
그래서 오늘은 저처럼 인텔리제이 한글 콘솔 문제를 겪고, 해결방법을 찾고 계신 분들을 위해서 간단하게 해결 방법을 소개해드리도록 하겠습니다 :)</p>

<h3 id="해결방법">해결방법</h3>

<p><img src="https://user-images.githubusercontent.com/95404736/235306346-ad3fb520-7f71-4d8b-bf81-dbbd97cd5edd.png" alt="image" width="500" /></p>

<p>인텔리제이 상단 메뉴에서 ‘Help - Edit Custom VM Options…‘를 찾아서 클릭합니다.</p>

<p><img width="600" alt="image" src="https://user-images.githubusercontent.com/95404736/235306442-3bf3857f-e4a3-4624-af58-7ee167f4c001.png" /></p>

<p>그럼 위 이미지에서 보이는 것처럼 파일이 하나 열리게 됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>-Dfile.encoding=UTF-8
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 코드를 이미지 두번째 줄처럼 붙여 넣어주세요.<br />
그리고 인텔리제이를 재시작하면 한글 깨짐 문제가 해결됩니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Issue" /><category term="인텔리제이" /><category term="IntelliJ" /><category term="한글" /><category term="한글깨짐" /><summary type="html"><![CDATA[인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기]]></summary></entry><entry><title type="html">CH12. 제품 소프트웨어 패키징</title><link href="http://localhost:4000/infoprocessing/post78/" rel="alternate" type="text/html" title="CH12. 제품 소프트웨어 패키징" /><published>2023-03-25T00:00:00+09:00</published><updated>2023-03-25T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post78</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post78/"><![CDATA[<h3 id="제품-소프트웨어-패키징-하기">제품 소프트웨어 패키징 하기</h3>

<h4 id="제품-소프트웨어-패키징product-software-packaging">제품 소프트웨어 패키징(Product Software Packaging)</h4>

<p>개발이 완료된 제품 소프트웨어를 고객에게 전달하기 위한 형태로 포장하는 과정</p>

<ul>
  <li>사용자 중심의 모듈 패키징 프로세스: 기능 식별 → 모듈화 → 빌드 진행 → 사용자 환경 분석 → 패키징 적용 시험 → 패키징 변경 개선</li>
</ul>

<h4 id="릴리즈-노트release-note">릴리즈 노트(Release Note)</h4>

<p>고객에게 개발 과정에서 정리된 제품의 릴리즈 정보를 제공하는 문서</p>

<ul>
  <li>릴리즈 노트 작성 프로세스: 모듈 식별 → 릴리즈 정보 확인 → 릴리즈 노트 개요 작성 → 영향도 체크 → 정식 릴리즈 노트 작성 → 추가 개선 항목 식별</li>
</ul>

<h4 id="제품-소프트웨어-패키징-도구">제품 소프트웨어 패키징 도구</h4>

<p>배포를 위한 패키징 시에 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능 제공하며, 안전한 유통과 배포를 보장하는 도구</p>

<h4 id="패키징-도구-활용-시-고려-사항">패키징 도구 활용 시 고려 사항</h4>

<ul>
  <li>암호화/보안 고려: 내부 콘텐츠에 대한 암호화 및 보안 고려</li>
  <li>이기종 연동을 고려: 이기종 콘테츠 및 단말기 간 DRM 연동 고려</li>
  <li>사용자 편의성 고려: 사용자 입장에서 문제를 고려하여 최대한 효율적으로 적용</li>
  <li>적합한 암호화 알고리즘 적용: 제품 소프트웨어 종류에 맞는 알고리즘을 선택하여 배포 시 범용성에 지장이 없도록 고려</li>
</ul>

<h4 id="저작권copyright">저작권(Copyright)</h4>

<p>창작물인 저작물에 대한 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한</p>

<h4 id="디지털-저작권-관리drm-digital-right-management">디지털 저작권 관리(DRM: Digital Right Management)</h4>

<p>저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠 관리 및 보호 기술</p>

<h4 id="디지털-저작권-관리drm-구성요소">디지털 저작권 관리(DRM) 구성요소</h4>

<ul>
  <li>콘텐츠 제공자(Content Provider): 콘텐츠를 제공하는 저작권자</li>
  <li>콘텐츠 소비자(Content Customer): 콘텐츠를 구매하여 사용하는 주체</li>
  <li>콘텐츠 분배자(Contents Distributor): 암호화된 콘텐츠를 유통하는 곳이나 사람</li>
  <li>클리어링 하우스(Clearing House): 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳</li>
  <li>DRM 콘텐츠(DRM Content): 서비스하고자 하는 암호화된 콘텐츠, 콘텐츠와 관련된 메타데이터, 콘텐츠 사용정보를 패키징하여 구성된 콘텐츠</li>
  <li>패키저(Packager): 콘텐츠를 메타데이터와 함꼐 배포 가능한 단위로 묶은 도구</li>
  <li>DRM 컨트롤러(DRM Controller): 배포된 디지털 콘텐츠의 이용 권한을 통제</li>
  <li>보안 컨테이너(Security Contatiner): 원본 콘텐츠를 안전하게 유통하기 위한 전자적 보안장치</li>
</ul>

<h4 id="패키징-도구-구성-세부-기술">패키징 도구 구성 세부 기술</h4>

<ul>
  <li>암호화: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술</li>
  <li>키 관리: 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술</li>
  <li>암호화 파일 생성: 콘텐츠 암호화된 콘텐츠로 생성하기 위한 기술</li>
  <li>식별 기술: 콘텐츠에 대한 식별 체계 표현 기술</li>
  <li>저작권 표현: 라이선스의 내용 표현 기술</li>
  <li>정책 관리: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술</li>
  <li>크랙방지: 크랙에 의한 콘텐츠 사용 방지 기술</li>
  <li>인증: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술</li>
</ul>

<h3 id="제품-소프트웨어-매뉴얼-작성-및-버전-등록">제품 소프트웨어 매뉴얼 작성 및 버전 등록</h3>

<h4 id="제품-소프트웨어-매뉴얼">제품 소프트웨어 매뉴얼</h4>

<p>사용자 측면에서 패키징 이후 설치, 제품 소프트웨어를 사용하는 데 필요한 주요 내용을 기록한 문서</p>

<h4 id="제품-소프트웨어-사용자-매뉴얼">제품 소프트웨어 사용자 매뉴얼</h4>

<p>사용자가 소프트웨어 사용에 필요한 내용을 포함한 문서</p>

<h4 id="제품-소프트웨어-배포본">제품 소프트웨어 배포본</h4>

<p>사용자가 사용하기 편하도록 배포 정보를 포함하여 개발된 컴포넌트 또는 패키지가 제품화된 형태</p>

<h4 id="백업-유형">백업 유형</h4>

<ul>
  <li>전체 백업(Full Backup): 백업받고자 하는 데이터 전체에 대한 백업을 하는 방식</li>
  <li>차등 백업(Differential Backup): 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식</li>
  <li>증분 백업(Incremental Backup): 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업하는 방식</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="제품" /><category term="제품소프트웨어패키징" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 제품 소프트웨어 패키징]]></summary></entry><entry><title type="html">CH11. 응용 SW 기초 기술 활용</title><link href="http://localhost:4000/infoprocessing/post77/" rel="alternate" type="text/html" title="CH11. 응용 SW 기초 기술 활용" /><published>2023-03-19T00:00:00+09:00</published><updated>2023-03-19T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post77</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post77/"><![CDATA[<h3 id="운영체제의-특징">운영체제의 특징</h3>

<h4 id="운영체제os-operating-system">운영체제(OS: Operating System)</h4>

<p>사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어</p>

<h5 id="운영체제-종류">운영체제 종류</h5>

<p>윈도우즈(Windows), 유닉스(Unix), 리눅스(Linux), 맥(Mac), 안드로이드(Android)</p>

<h4 id="메모리-관리-기법">메모리 관리 기법</h4>

<ul>
  <li>반입 기법: 메모리 적재 시기 결정(When)</li>
  <li>배치 기법: 메모리 적재 위치 결정(Where)</li>
  <li>할당 기법: 메모리 적재 방법 결정(How)</li>
  <li>교체 기법: 메모리 교체 대상 결정(Who)</li>
</ul>

<h4 id="메모리-배치-기법">메모리 배치 기법</h4>

<ul>
  <li>최초 적합(First-fit): 프로세스가 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식</li>
  <li>최적 적합(Best fit): 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재하는 방식</li>
  <li>최악 접합(Worst-fit): 프로세스의 가용 공간들 중에서 가장 큰 공간에 할당하는 방식</li>
</ul>

<h4 id="프로세스-상태">프로세스 상태</h4>

<ul>
  <li>생성(Create) 상태: 사용자에 의해 프로세스가 생성된 상태</li>
  <li>준비(Ready) 상태: CPU를 할당받을 수 있는 상태</li>
  <li>실행(Running) 상태: 프로세스가 CPU를 할당받아 동작 중인 상태</li>
  <li>대기(Waiting) 상태: 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태</li>
  <li>완료(Complete) 상태: 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태</li>
</ul>

<h4 id="프로세스-상태-전이">프로세스 상태 전이</h4>

<p><img width="618" alt="image" src="https://user-images.githubusercontent.com/95404736/226170556-97d36ab6-f195-4c78-a98f-20e9b023729f.png" /></p>

<h4 id="프로세스-스케줄링의-유형">프로세스 스케줄링의 유형</h4>

<ul>
  <li>선점형 스케줄링: 우선순위가 높은 프로세스가 CPU를 점유하는 스케줄링
    <ul>
      <li>라운드 로빈(Round Robbin): 프로세스는 같은 크기의 CPU 시간 할당</li>
      <li>SRT(Shortest Remaining Time First): 가장 짧은 시간이 소요되는 프로세스를 먼저 수행</li>
      <li>다단계 큐(Multi Level Queue): 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점</li>
      <li>다단계 피드백 큐(Multi Level Feedback Queue): 큐마다 서로 다른 CPU시간 할당량을 부여, FIFO+라운드 로빈 스케줄링 기법 혼합</li>
    </ul>
  </li>
  <li>비선점형 스케줄링: 한 프로세스가 CPU를 할당 받으면 작업 종료 전까지 다른 프로세스는 CPU점유 불가능한 스케줄링
    <ul>
      <li>우선순위(Priority): 프로세스별 우선순위에 따라 CPU 할당</li>
      <li>기한부(Deadline): 작업들이 명시된 기한 내에 완료되도록 계획</li>
      <li>FCFS(First Come First Service): 프로세스가 대기 큐에 도착한 순서에 따라 CPU할당=FIFO</li>
      <li>SJF(Shortest Job First): 가장 짧은 작업부터 수행, 평균 대시 시간 최소화. 기아현상 발생</li>
      <li>HRN(Highest Response Ratio Next): 대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 기법</li>
    </ul>
  </li>
</ul>

<h4 id="가상화virtualization">가상화(Virtualization)</h4>

<p>물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술</p>

<h4 id="클라우드-컴퓨팅cloud-computing">클라우드 컴퓨팅(Cloud Computing)</h4>

<p>인터넷을 통해 가상화된 컴퓨터 시스템 리소스 제공</p>

<h4 id="클라우드-컴퓨팅-유형">클라우드 컴퓨팅 유형</h4>

<ul>
  <li>인프라형 서비스(IaaS: Infrastructure as a Service): 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스</li>
  <li>플랫폼형 서비스(Paas: Platform as a Service): 애플리케이션 개발, 실행, 관리할 수 있게하는 플랫폼을 제공하는 서비스</li>
  <li>소프트웨어형 서비스(SaaS: Software as a Service): 클라이언트 통해 접속하여 소프트웨어 서비스 형태로 이용하는 서비스</li>
</ul>

<h3 id="네트워크-계층-구조-파악">네트워크 계층 구조 파악</h3>

<h4 id="네트워크network">네트워크(Network)</h4>

<p>원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라</p>

<ul>
  <li>광대역 네트워크(WAN): LAN에 비해 전송거리가 넓음</li>
  <li>근거리 네트워크(LAN): 한 건물 또는 작은 지역 커버</li>
</ul>

<h4 id="osiopen-system-interconnection-7계층">OSI(Open System Interconnection) 7계층</h4>

<ul>
  <li>응용 계층(Application Layer): 사용자와 네트워크 간 응용서비스 연결, 데이터 생성</li>
  <li>표현 계층(Presentation Layer): 데이터 형식 설정, 부호교환, 암/복호화</li>
  <li>세션 계층(Session Layer): 송수신 간의 논리적인 연결</li>
  <li>전송 계층(Transport Layer): 송수신 프로세스 간의 연결</li>
  <li>네트워크 계층(Network Layer): 단말기 간 데이터 전송을 위한 최적화된 경로 제공</li>
  <li>데이터링크 계층(Data Link Layer): 인접 시스템 간 데이터 전송, 전송 오류 제어</li>
  <li>물리 계층(Physical Layer): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환</li>
</ul>

<h4 id="프로토콜protocol">프로토콜(Protocol)</h4>

<p>서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약</p>

<h4 id="프로토콜-기본-3요소">프로토콜 기본 3요소</h4>

<ul>
  <li>구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규적</li>
  <li>의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정</li>
  <li>타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정</li>
</ul>

<h4 id="네트워크-프로토콜network-protocol">네트워크 프로토콜(Network Protocol)</h4>

<p>컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계</p>

<h4 id="데이터-링크-계층-프로토콜">데이터 링크 계층 프로토콜</h4>

<ul>
  <li>HDLC(High-level Data Link Control): 점대점 방식이나 다중방식 통신에 사용되며, 동기식 비트 중심</li>
  <li>PPP(Point-to-Point Protocol): 네트워크 분야에서 두 통신 노드 간의 직접적인 연결</li>
  <li>프레임 릴레이(Frame Relay): 프로토콜 처리를 간략화하여 데이터 처리속도의 향상 및 전송 지연을 감소시킨 고속데이터 전송 기술</li>
  <li>ATM(Asynchronous Transport Mode): 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술</li>
</ul>

<h4 id="네트워크-계층-프로토콜">네트워크 계층 프로토콜</h4>

<ul>
  <li>IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용</li>
  <li>ARP(Adress Resolution Protocol): IP네트워크상에서 IP주소를 MAC주소(물리주소)로 변환하는 프로토콜</li>
  <li>RARP(Reverse Address Resolution Protocol): 서버로부터 IP 주소를 요청하기위해 사용하는 프로토콜</li>
  <li>ICMP(Internet Control Message Protocol): IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜</li>
  <li>IGMP(Internet Group Managemnet Protocol): 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜</li>
  <li>라우팅 프로토콜(Routing Protocol): 데이터 전송을 위해 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜</li>
</ul>

<h4 id="ipv4-internet-protocol-version-4">IPv4 (Internet Protocol version 4)</h4>

<p>인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층 프로토콜</p>

<ul>
  <li>8비트씩 4부분으로 나뉜 10진수</li>
  <li>0~255까지 3자리수 표현</li>
  <li>유니캐스트, 멀티캐스트, 브로드캐스트</li>
</ul>

<h4 id="ipv4-클래스-분류">IPv4 클래스 분류</h4>

<ul>
  <li>A클래스: 국가나 대형 통신망에 사용(1~127), 네트워크 사용자에게 부여가 가능한 IP</li>
  <li>B클래스: 중대형 통신망에 사용(128~191)</li>
  <li>C클래스: 소규모 통신망에 사용(192~223)</li>
  <li>D클래스: 멀티캐스트 용도로 예약된 주소(224~239)</li>
  <li>E클래스: 연구를 위해 예약된 주소(공용 사용 불가)</li>
</ul>

<h4 id="ipv6-internet-protocol-version-6-ipv4의-주소-부족-문제를-해결하기-위해-개발">IPv6 (Internet Protocol version 6): IPv4의 주소 부족 문제를 해결하기 위해 개발</h4>

<ul>
  <li>IPv4에 비해 자료 전송속도가 빠름</li>
  <li>128비트 주소체계</li>
  <li>16비트씩 8개 부분으로 나눈 16진수</li>
  <li>유니캐스트, 멀티캐스트, 애니캐스트</li>
</ul>

<h4 id="ipv4에서-ipv6으로-전환-방법-듀얼-스택-터널링-주소-변환-방식">IPv4에서 IPv6으로 전환 방법: 듀얼 스택, 터널링, 주소 변환 방식</h4>

<h4 id="라우팅-프로토콜">라우팅 프로토콜</h4>

<ul>
  <li>내부 라우팅 프로토콜(IGP)
    <ul>
      <li>RIP(Routing Information Protocol): AS(자율시스템)내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜</li>
      <li>OSPF(Oepn Shortest Path First): 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜</li>
    </ul>
  </li>
  <li>외부 라우팅 프로토콜(EGP)
    <ul>
      <li>BGP(Border Gateway Protocol): AS상호 간에 경로 정보를 교환하기 위한 라우팅 프로토콜</li>
    </ul>
  </li>
</ul>

<h4 id="tcptransmission-control-protocol">TCP(Transmission Control Protocol):</h4>

<ul>
  <li>TCP 특징: 신뢰성 보장, 연결 지향적 특징, 흐름 제어, 혼잡 제어</li>
</ul>

<h4 id="udpuser-datagram-protocol">UDP(User Datagram Protocol):</h4>

<ul>
  <li>UDP 특징: 비신뢰성, 순서화되지 않은 데이터그램 서비스 제공, 실시간 응용 및 멀티캐스트 가능, 단순 헤어</li>
</ul>

<h4 id="표현계층-프로토콜">표현계층 프로토콜</h4>

<ul>
  <li>JPEG: 이미지를 위해 만들어진 표준 규격</li>
  <li>MPEG: 멀티미디어(비디오, 오디오)를 위해 만들어진 표준 규격</li>
</ul>

<h4 id="응용계층-프로토콜">응용계층 프로토콜</h4>

<ul>
  <li>HTTP(Hyper Text Transfer Protocol): 텍스트 기반의 통신구약, 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜</li>
  <li>FTP(File Transfer Protocol): TCP/IP를 갖고 서버와 클라이언트 사이의 파일을 전송하기 위한 프로토콜</li>
  <li>SMTP(Simple Mail Transfer Protocol): 인터넷에서 TCP포트 25번을 사용하여 이메일을 보내기 위해 이용되는 프로토콜</li>
  <li>POP3(Post Office Protocol Version 3): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는 데 사용하는 프로토콜</li>
  <li>IMAP(Internet Messaging Access Protocol): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는 데 사용하는 프로토콜</li>
  <li>Telnet: 인터넷이나 로컬 영역에서 네트워크 연결에 사용되는 네트워크 프로토콜</li>
  <li>SSH(Secure Shell): 서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 쉘 서비스 등을 수행, Telent보다 강력한 보안 제공</li>
  <li>SNMP(Simple Network Managemnet Protocol): 라우터나 허브 등 네트워크 장치로부터 정보를 수집 및 관리</li>
</ul>

<h4 id="패킷-교환-방식packet-switching">패킷 교환 방식(Packet Switching)</h4>

<p>작은 블록의 패킷으로 데이터를 전송하여 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 통신 방식</p>

<ul>
  <li>활용: 이메일, 메시지</li>
</ul>

<h4 id="패킷-교환-방식-기술">패킷 교환 방식 기술</h4>

<ul>
  <li>X.25: 통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜</li>
  <li>프레임 릴레이: ISDN을 사용하기 위한 프로토콜로서 ITU-T에 의해 표준으로 작성</li>
  <li>ATM(Asynchronous Transfer Mode): 비동기 전송모드, 광대역 전송에 쓰이는 스위칭 기법</li>
</ul>

<h4 id="서킷-교환-방식circuit-switching">서킷 교환 방식(Circuit Switching)</h4>

<p>네트워크 리스소를 특정 사용층이 독접하도록 하는 통신 방식</p>

<ul>
  <li>활용: 영상, 비디오</li>
</ul>

<h4 id="애드-혹-네트워크ad-hoc-network">애드 혹 네트워크(Ad-hoc Network)</h4>

<p>노드들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크</p>

<h3 id="기본-개발환경-구축하기">기본 개발환경 구축하기</h3>

<h4 id="개발환경-인프라-구성-방식">개발환경 인프라 구성 방식</h4>

<ul>
  <li>온프레미스(On-Premise) 방식: 외부 인터넷망이 차단된 상태에서 인트라넷망만을 활용하여 개발환경을 구축하는 방식</li>
  <li>클라우드(Cloud) 방식: 클라우드 공습 서비스를 제공하는 회사들(아마존, 구글, MS 등)의 서비스를 임대하여 개발 환경을 구축하는 방식</li>
  <li>하이브리드(Hybrid) 방식: 온프레미스와 클라우드 방식을 혼용한 방식</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="응용SW" /><category term="소프트웨어" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 응용 SW 기초 기술 활용]]></summary></entry><entry><title type="html">CH10. 애플리케이션 테스트 관리</title><link href="http://localhost:4000/infoprocessing/post76/" rel="alternate" type="text/html" title="CH10. 애플리케이션 테스트 관리" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post76</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post76/"><![CDATA[<h3 id="애플리케이션-테스트-케이스-설계">애플리케이션 테스트 케이스 설계</h3>

<h4 id="애플리케이션-테스트">애플리케이션 테스트</h4>

<p>애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차</p>

<h4 id="애플리케이션-테스트-원리">애플리케이션 테스트 원리</h4>

<ul>
  <li>완벽한 테스팅은 불가능: 결함을 줄일 수는 있으나, 결함이 없다고 증명할 수 없음</li>
  <li>파레토 법칙(Pareto Principle): 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙</li>
  <li>살충제 패러독스(Pesticide Paradox): 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상</li>
  <li>정황 의존성: 소프트웨어 성격에 맞게 테스트 실시</li>
  <li>오류-부재의 궤변: 요구사항을 충족시키주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음</li>
</ul>

<h4 id="프로그램-실행-여부에-따른-분류">프로그램 실행 여부에 따른 분류</h4>

<ul>
  <li>정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트 (리뷰, 정적 분석)</li>
  <li>동적 테스트: 소프트웨어 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트 (화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트)</li>
</ul>

<h4 id="화이트박스-테스트white-box-test">화이트박스 테스트(White-Box Test)</h4>

<p>원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 (구조 검사)</p>

<h5 id="화이트박스-테스트-유형">화이트박스 테스트 유형</h5>

<ul>
  <li>구문(문장) 커버리지 : 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지</li>
  <li>결정(선택, 분기) 커버리지 : 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건/결정 커버리지 : 전체 조건식 &amp; 개별 조건식 모두 참 한번, 거짓 한 번 결과가 되도록 수행하는 커버리지</li>
  <li>변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지</li>
  <li>다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지</li>
  <li>기본 경로 커버리지 : 수행 가능한 모든 경로를 테스트 하는 기법</li>
  <li>제어 흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법</li>
  <li>데이터 흐름 테스트 : 제어 흐름 그래프에 사용현황 추가한 테스트 기법</li>
</ul>

<h4 id="블랙박스-테스트black-box-test">블랙박스 테스트(Black-Box Test)</h4>

<p>사용자의 요구사항 명세를 보면서 수행하는 테스트 (기능 검사)</p>

<h5 id="블랙박스-테스트-유형">블랙박스 테스트 유형</h5>

<ul>
  <li>동등 분할 테스트 : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법</li>
  <li>경곗값 분석 테스트 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법</li>
  <li>결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트</li>
  <li>상태 전이 테스트 : 이벤트에 의해 어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트</li>
  <li>유스케이스 테스트 : 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트</li>
  <li>분류 트리 테스트 : SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계하여 테스트</li>
  <li>페어와이즈 테스트 : 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식</li>
  <li>원인-결과 그래프 테스트 : 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선정하여 테스트</li>
  <li>비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트</li>
</ul>

<h4 id="테스트-시각에-따른-분류">테스트 시각에 따른 분류</h4>

<ul>
  <li>검증(Verification): 소프트웨어 개발 과정을 테스트, 개발자 또는 시험자의 시각</li>
  <li>확인(Validation): 소프트웨어 결과를 테스트, 사용자 시각</li>
</ul>

<h4 id="테스트-목적에-따른-분류">테스트 목적에 따른 분류</h4>

<ul>
  <li>회복 테스트(Recovery Testing): 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트 하는 기법</li>
  <li>안전 테스트(Security Testing): 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법</li>
  <li>성능 테스트(Perfomance Testing): 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법</li>
  <li>구조 테스트(Structure Testing): 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법</li>
  <li>회귀 테스트(Refression Testing): 시스템의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트</li>
  <li>병행 테스트(Parallel Testing): 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법</li>
</ul>

<h4 id="성능-테스트의-상세-유형">성능 테스트의 상세 유형</h4>

<ul>
  <li>부하 테스트(Load Testing): 시스템에 부가를 계속 증가시켜 시스템의 임계점을 찾는 테스트</li>
  <li>강도 테스트(Stress Testing): 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 테스트</li>
  <li>스파이크 테스트(Spike Testing): 짧은 시간에 사용자가 몰릴 때 시스템의 반응 층정 테스트</li>
  <li>내구성 테스트(Endurance Testing): 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트</li>
</ul>

<h4 id="테스트-종류에-따른-분류">테스트 종류에 따른 분류</h4>

<ul>
  <li>명세 기반 테스트(블랙박스 테스트): 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트 하는 기법</li>
  <li>구조 기반 테스트(화이트박스 테스트): 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법</li>
  <li>경험 기반 테스트(블랙박스 테스트): 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트</li>
</ul>

<h4 id="테스트-케이스test-case">테스트 케이스(Test Case)</h4>

<p>사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서</p>

<h4 id="테스트-오라클test-oracle">테스트 오라클(Test Oracle)</h4>

<p>테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법</p>

<h5 id="테스트-오라클-종류">테스트 오라클 종류</h5>

<ul>
  <li>참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 제공하는 오라클</li>
  <li>샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클</li>
  <li>휴리스틱(Heuristic) 오라클: 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정(휴리스틱)으로 처리하는 오라클</li>
  <li>일관성 검사(Consistent) 오라클: 애플리케이션 변경이 있을 때, 수행 전과후의 결괏값이 동일한지 확인하는 오라클</li>
</ul>

<h4 id="테스트-레벨test-level">테스트 레벨(Test Level)</h4>

<p>함께 편성되고 관리되는 테스트 활동의 그룹</p>

<h5 id="테스트-레벨-종류">테스트 레벨 종류</h5>

<ul>
  <li>단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트 하는 단계</li>
  <li>통합 테스트: 단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</li>
  <li>시스템 테스트: 개발된 소프트웨어가 정상적으로 수행되는지 검증하는 테스트</li>
  <li>인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트</li>
</ul>

<h4 id="소프트웨어-개발단계">소프트웨어 개발단계</h4>

<p>요구사항 → 분석 → 설계 → 구현</p>

<h4 id="테스트-단계">테스트 단계</h4>

<p>단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트</p>

<h4 id="인수-테스트">인수 테스트</h4>

<ul>
  <li>사용자 인수 테스트: 사용자가 시스템 사용의 적절성 여부를 확인</li>
  <li>운영상의 인수 테스트: 시스템 관리자가 시템 인수 시 수행하는 테스트 기법</li>
  <li>계약 인수 테스트: 계약상의 인수/검수 조건을 준수하는지 여부를 확인</li>
  <li>규정 인수 테스트: 소프트웨어가 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인</li>
  <li>알파 테스트: 개발자의 장소에서 사용자가 개발자와 함께 행하는 테스트 기법</li>
  <li>베타 테스트: 실제 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 테스트</li>
</ul>

<h4 id="테스트-시나리오test-scenario">테스트 시나리오(Test Scenario)</h4>

<p>테스트 수행을 위한 여러 테스트 케이스의 집합, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서</p>

<h3 id="애플리케이션-통합-테스트">애플리케이션 통합 테스트</h3>

<h4 id="단위-테스트unit-test">단위 테스트(Unit Test)</h4>

<p>개별적인 모듈(또는 컴포넌트)을 테스트</p>

<h4 id="목mock-객체-생성-프레임워크">목(Mock) 객체 생성 프레임워크</h4>

<p>객체 지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존하는데 이런 경우 메서드를 고립화하여 테스트하는 것이 불가능하므로 독집적인 컴포넌트 테스트를 위해서는 스텁의 객체 지향 버전인 목 객체가 필요하다</p>

<h5 id="목-객체-유형-더미-객체-테스트-스텁-테스트-드라이버-테스트-스파이-가짜-객체">목 객체 유형: 더미 객체, 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체</h5>

<h4 id="통합-테스트intergration-test">통합 테스트(Intergration Test)</h4>

<p>단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</p>

<h5 id="통합-테스트-수행-방법-간-비교">통합 테스트 수행 방법 간 비교</h5>

<ul>
  <li>빅뱅 테스트: 모든 모듈을 동시에 통합 후 테스트 수행
    <ul>
      <li>드라이브/스텁: 드라이버/스텁 없이 실제 모듈로 테스트</li>
    </ul>
  </li>
  <li>상향식 테스트: 최하위 모듈부터 점진적으로 상위 모듈과 함께 테스트
    <ul>
      <li>드라이브/스텁: 테스트 드라이버 필요</li>
    </ul>
  </li>
  <li>하향식 테스트: 최상위 모듈부터 하위 모듈들을 통합하면서 테스트
    <ul>
      <li>드라이브/스텁: 테스트 스텁 필요</li>
    </ul>
  </li>
  <li>샌드위치 테스트: 상위는 하향식+하위는 상향식 테스
    <ul>
      <li>드라이브/스텁: 테스트스텁, 드라이버 필요</li>
    </ul>
  </li>
</ul>

<h4 id="테스트-자동화-도구">테스트 자동화 도구</h4>

<p>반복적인 테스트 작업을 스크립트 형태로 구현함으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 있는 방법</p>

<h4 id="테스트-자동화-도구-유형">테스트 자동화 도구 유형</h4>

<ul>
  <li>정적 분석 도구(Static Analysis Tools): 만들어진 애플리케이션을 실행하지 않고 분석하는 도구</li>
  <li>테스트 실행 도구(Test Execution Tools): 테스트를 위해 작성된 스크립트를 실행하고, 스크립트 언어를 사용하여 테스트를 실행하는 도구</li>
  <li>성능 테스트 도구(Perfomance Test Tools): 가상의 사용자를 생성하고 테스트를 수행하여 목표를 달성했는지 확인 하는 도구</li>
  <li>테스트 통제 도구(Test Control Tools): 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구</li>
  <li>테스트 하네스 도구(Test Harness Tools): 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구</li>
</ul>

<h4 id="테스트-하네스-구성요소-테스트-드라이버-테스트-스텁-테스트-슈트-테스트-케이스-테스트-시나리오-테스트-스크립트-목-오브젝트">테스트 하네스 구성요소: 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 시나리오, 테스트 스크립트, 목 오브젝트</h4>

<h4 id="소프트웨어-결함-개발자-오류로-인해-만들어지는-문서-또는-코딩상의-결점으로-개발자가-설계한-것과-다르게-동작하거나-다른-결과가-발생하는-현상">소프트웨어 결함: 개발자 오류로 인해 만들어지는 문서 또는 코딩상의 결점으로 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 현상</h4>

<h4 id="테스트-결함-관리-단계별-테스트-수행-후-발생한-결함의-재발-방지와-유사-결함-발견-시-처리-시간-단축을-위해-결함을-추적하고-관리하는-활동">테스트 결함 관리: 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동</h4>

<h4 id="결함-분석-방법">결함 분석 방법</h4>

<ul>
  <li>구체화: 결함의 원인을 찾기 위해 결함을 발생기킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법</li>
  <li>고립화: 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법</li>
  <li>일반화: 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법</li>
</ul>

<h4 id="테스트-커버리지test-coverage">테스트 커버리지(Test Coverage)</h4>

<p>주어진 테스트 케이스에 의해 수행되는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준</p>

<h4 id="테스트-커버리지-유형">테스트 커버리지 유형</h4>

<ul>
  <li>기능 기반 커버리지: 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법</li>
  <li>라인 커버리지: 전체 소스 코드의 라인수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인수를 측정하는 방법</li>
  <li>코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법</li>
</ul>

<h4 id="결함-심각도별-분류">결함 심각도별 분류</h4>

<p>단순 결함(미관상 안좋음) → 경미한 결함(표준위반) → 보통 결함(사소한 기능 오작동) → 주요 결함(기능 장애) → 치명적 결함(데이터손실)</p>

<h4 id="결함-우선순위">결함 우선순위</h4>

<p>낮음(Low) → 보통(Medium) → 높음(High) → 결정적(Critical)</p>

<h3 id="애플리케이션-성능-개선">애플리케이션 성능 개선</h3>

<ul>
  <li>tch: 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생</li>
  <li>연결 누수(Connection Leak): DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생</li>
  <li>부적절한 커넥션 풀 크기(Connection Pool Size): 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생할 가능성 존재</li>
  <li>확정(Commint) 관련: 트랜잭션이 확정 되지 않고 커넥션 풀에 반환될 떄 성능 저하 가능성 존재</li>
</ul>

<h4 id="베드-코드bad-code-프로그램-로직이-복잡하고-다른-개발자들이-이해하기-어려운-코드">베드 코드(Bad Code): 프로그램 로직이 복잡하고 다른 개발자들이 이해하기 어려운 코드</h4>

<ul>
  <li>베드 코드 사례
    <ul>
      <li>외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드</li>
      <li>스파게티 코드: 소스 코드가 복잡하게 얽힌 모습, 정상 작동 하지만 코드의 작동을 파악하기 어려운 코드</li>
      <li>알 수 없는 변수명: 변수나 메서드에 대한 이름 정의를 알 수 없는 코드</li>
      <li>로직 중복: 동일한 처리 로직이 중복되게 작성된 코드</li>
    </ul>
  </li>
</ul>

<h4 id="클린-코드clean-code">클린 코드(Clean Code)</h4>

<p>가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드</p>

<ul>
  <li>클린 코드 특징: 가독성이 높아 쉽게 이해됨, 개선도 쉬움, 버그찾기도 쉬워 프래그래밍 속도 빨라짐</li>
  <li>클린 코드 작성 원칙: 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화</li>
</ul>

<h4 id="리팩토링refactoring">리팩토링(Refactoring)</h4>

<p>기능을 변경하지 않고, 복잡한 소스코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="테스트" /><category term="애플리케이션" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 애플리케이션 테스트 관리]]></summary></entry><entry><title type="html">CH09. 소프트웨어 개발 보안 구축</title><link href="http://localhost:4000/infoprocessing/post75/" rel="alternate" type="text/html" title="CH09. 소프트웨어 개발 보안 구축" /><published>2023-03-13T00:00:00+09:00</published><updated>2023-03-13T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post75</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post75/"><![CDATA[<h3 id="소프트웨어-개발-보안-설계">소프트웨어 개발 보안 설계</h3>

<h4 id="sw-개발-보안">SW 개발 보안</h4>

<p>소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동</p>

<ul>
  <li>SW 개발 보안 생명주기: 요구사항 명세 → 설계 → 구현 → 테스트 → 유지보수</li>
</ul>

<h4 id="sw-개발-보안-3대-요소">SW 개발 보안 3대 요소</h4>

<ul>
  <li>기밀성(Confidentiality): 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용</li>
  <li>무결성(Integrity): 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음</li>
  <li>가용성(Availability): 인가받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용할 수 있음</li>
</ul>

<h4 id="dosdenial-of-service-공격">DoS(Denial of Service) 공격</h4>

<p>시스템을 악의적으로 공객해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격</p>

<h4 id="dos-공격의-종류">DoS 공격의 종류</h4>

<ul>
  <li>SYN 플러딩(SYN Flooding): 서버의 동시 가용 사용자수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격</li>
  <li>UDP 플러딩(UDP Flooding): 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키는 공격</li>
  <li>스퍼프(Smurf)/스머핑(Smurfing): 출발지 주소를 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo패킷을 직접 브로드캐스팅하여 마비시키는 공격</li>
  <li>죽음의 핑(PoD: Ping of Death): ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하여 정상적인 서비스를 못하도록 하는 공격</li>
  <li>랜드 어택(Land Attack): 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보내 시스템의 가용성을 침해하는 공격</li>
  <li>티어 드롭(Tear Drop): IP패킷의 재조합 과정에서 잘못된 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격</li>
  <li>봉크(Bonk)/보잉크(Boink): 프로토콜의 오류 제어를 이용한 공격기법</li>
</ul>

<h4 id="ddosdistributed-denial-of-service">DDoS(Distributed Denial of Service)</h4>

<p>여러 대의 공격자를 분산 배치하여 동시에 동작하게함으로써 특정 사이트를 공격하는 기법</p>

<h4 id="ddos-공격도구">DDos 공격도구</h4>

<ul>
  <li>Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구</li>
  <li>Tribe Flood Network: 많은 소스에서 하나 혹은 여러개의 목표 시스템에 대해 서비스 거부 공격을 수행할 수 있는 도구</li>
  <li>Stacheldraht: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구</li>
</ul>

<h4 id="dos와-ddos-차이">DoS와 DDoS 차이</h4>

<ul>
  <li>DoS는 직접 공격, DDoS는 공격하도록 지시</li>
  <li>DoS는 한 사람에 의해 공격을 감행, DDoS는 수많은 감염 호스트를 통해 공격을 감행</li>
</ul>

<h4 id="drdosdistributed-reflection-dos">DRDoS(Distributed Reflection DoS)</h4>

<p>공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부(DoS)가 되는 공격</p>

<h4 id="세션-하이재킹session-hijacking">세션 하이재킹(Session Hijacking)</h4>

<p>TCP의 세션 관리 취약점을 이용한 공격 기법, 케빈 미트닉이 사용</p>

<h4 id="애플리케이션-공격기법">애플리케이션 공격기법</h4>

<ul>
  <li>HTTP GET 플러딩: 과도한 Get 메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격</li>
  <li>Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 대상 웹 서버와 연결상태를 장시간 지속시키고 연결자원을 모두 소진시키는 서비스 거부 공격</li>
  <li>RUDY: 요청 헤더의 Content-Length를 비상장으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격</li>
  <li>Slow HTTP Read DoS: 다수 HTTP 패킷을 지속적으로 전송하여 웹서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격</li>
  <li>Hulk DoS: 공격자가 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET요청을 발생시키는 서비스 거부 공격</li>
  <li>Hash DoS: 많은 수의 파라미터를 POST방식으로 웹서버로 전달하여 다수의 해시 출돌을 발생시켜서 자원을 소모시키는 서비스 거부 공격</li>
</ul>

<h4 id="네트워크-공격">네트워크 공격</h4>

<ul>
  <li>스니핑: 공격대상의 데이터만 몰래 들여다보는 수동적 공격 기법</li>
  <li>네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구</li>
  <li>패스워드 크래킹
    <ul>
      <li>사전 크래킹: ID와PW가 될 가능성이 있는 단어를 파일로 만들어 파일의 단어를 대입하여 크랙하는 공격 기법</li>
      <li>무차별 크래킹: 무작위로 패스워드 자리에 대입하여 패스워드를 알아내는 공격 기법</li>
      <li>패스워드 하이브리드 공격: 사전공격+무차별공격</li>
      <li>레인보우 테이블 공격: 크래킹 하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법</li>
    </ul>
  </li>
  <li>IP 스푸핑: 침입자가 인증된 컴퓨팅 시스템인 것처럼 속여서 인증된 호스트의 IP 주소로 위조하여 타깃에 정송하는 공격 기법</li>
  <li>ARP 스푸핑: 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송</li>
  <li>ICMP Redirect 공격: 스니핑 시스템을 네트워크에 존재하는 또다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격 기법</li>
  <li>트로이 목마: 악성 루틴이 숨어있는 프로그램, 실행하면 악성 코드를 실행</li>
</ul>

<h4 id="버퍼-오버플로우buffer-overflow-공격">버퍼 오버플로우(Buffer Overflow) 공격</h4>

<p>메모리에 할당도니 버퍼 크기를 초과하는 양의 데이터를 입력하여 프로세스의 흐름을 변경시켜서 악성 코드를 실행 시키는 공격 기법</p>

<h4 id="백도어backdoor">백도어(Backdoor)</h4>

<p>허가받지 않고 시스템에 접속하는 권리, 정상적인 인증 절차를 우회하는 기법</p>

<h4 id="보안-관련-용어">보안 관련 용어</h4>

<ul>
  <li>스피어 피싱(Spear Phishing): 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도하여 사용자의 개인정보 탈취하는 공격기법</li>
  <li>스미싱(Smishing): SMS(문자)를 이용하여 개인 비밀정보를 요구하거나 휴대폰 소액 결제를 유도하는 피싱 공격</li>
  <li>큐싱(Qshing): QR코드를 통해 악성 앱을 내려받도록 유도하여 금융 정보 등을 뺴내는 피싱 공격</li>
  <li>봇넷(Botnet): 악성 프로그램이감염되어 있는 컴퓨터들이 네트워크로 연결된 형태</li>
  <li>APT 공격(Advanced Persistent Threat): 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법</li>
  <li>공급망 공격(Supply Chain Atack): SW개발사의 네트워크에 침투하여 악의적 코드를 삽입, 서버 배포하여 사용자가 설치 또는 업데이트시에 자동적으로 감염되도록 하는 공격 기법</li>
  <li>제로데이 공격(Zero Day Attack): 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격 기법</li>
  <li>웜(Worm): 스스로 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 프로그램</li>
  <li>악성 봇(Malicious Bot): 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램 또는 코드</li>
  <li>사이버 킬체인(Cyber Kill Chain): 공격형 방위시스템, APT공격방어 분석 모델</li>
  <li>랜섬웨어(Ransomware): 시스템의 파일을 암호화하여 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어</li>
  <li>이블 트윈(Evil Twin) 공격: 핫스팟에 연결한 무선 사용자들의 정보르 탈취하는 무선 네트워크 공격 기법</li>
</ul>

<h4 id="서버-인증의-기능">서버 인증의 기능</h4>

<p>스니핑 방지(SSL인증서 설치), 피싱 방지, 데이터 변조 방지, 기업 신뢰도 향상(기업 인증)</p>

<h4 id="인증-기술의-유형">인증 기술의 유형</h4>

<ul>
  <li>지식기반 인증: 사용자가 기억하고 있는 지식 (ID/PW)</li>
  <li>소지기반 인증: 소지하고 있는 사용자 물품 (공인인증서, OTP)</li>
  <li>생체기반 인증: 고유한 사용자의 생체 정보 (홍채, 얼굴, 지문)</li>
  <li>특정기반 인증: 사용자의 특징을 활용 (서명, 몸짓)</li>
</ul>

<h4 id="접근-통제-기법">접근 통제 기법</h4>

<ul>
  <li>식별(Identification): 자신이 누구라고 시스템에 밝히는 행위</li>
  <li>인증(Authentication): 주체의 신원을 검증하기 위한 활동</li>
  <li>인가(Authorization): 인증된 주체에게 접근을 허용하는 활동</li>
  <li>책임추적성(Accountability): 주체의 접근을 추적하고 행동을 기록하는 활동</li>
</ul>

<h4 id="서버-접근-통제-유형">서버 접근 통제 유형</h4>

<ul>
  <li>임의적 접근 통제(DAC): 신분에 근거하여 객체에 대한 접근을 제한하는 방법</li>
  <li>강제적 접근 통제(MAC): 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법</li>
  <li>역할 기반 접근 통제(RBAC): 중앙 관리자가 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법</li>
</ul>

<h4 id="접근-통제-보호-모델">접근 통제 보호 모델</h4>

<ul>
  <li>벨-라파듈라 모델(BLP): 미 국방부지원 보안 모델, 보안 요소 중 기밀성을 가종하며 강제적 정책에 의해 접근 통제하는 모델
    <ul>
      <li>No Read Up: 보안수준이 낮은 주체는 보안 수준이 높은 객체를 읽어서는 안 됨</li>
      <li>No Write Down: 보안수준이 높은 주체는 보안 수준이 낮은 객체에 기록하면 안 됨</li>
    </ul>
  </li>
  <li>비바 모델: 무결성을 보장하는 최초 모델
    <ul>
      <li>No Read Down: 높은 등급의 주체는 낮은 등급의 객체를 읽을 수 없음</li>
      <li>No Wirte Up: 낮은 등급의 주체는 상위 등급의 객체를 수정 할 수 없음</li>
    </ul>
  </li>
</ul>

<h4 id="암호-알고리즘encryption-algorithm-데이터의-무결성-및-기밀성-확보를-위해-정보를-쉽게-해독할-수-없는-형태로-변환하는-기법">암호 알고리즘(Encryption Algorithm): 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독할 수 없는 형태로 변환하는 기법</h4>

<ul>
  <li>양방향 방식: 대칭 키 암호 방식, 비대칭 키 암호 방식</li>
  <li>일방향 해시함수 방식: MDC, MAC</li>
</ul>

<h4 id="대칭-키-암호-방식-암호화와-복호화에-같은-암호-키를-쓰는-알고리즘">대칭 키 암호 방식: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘</h4>

<ul>
  <li>블록 암호 방식: 고정 길이의 블록을 암호화하여 반복하는 알고리즘(EDS, AES, SEED)</li>
  <li>스트림 암호 방식: 매우긴 주기의 난수열을 발새이켜 평문과 더불어 암호문을 생성하는 방식(RC4)</li>
</ul>

<h4 id="비대칭-키-암호-방식">비대칭 키 암호 방식</h4>

<p>개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식, 공개키는 누구나 알수 있으나 개인키는 키의 소유자만 알고 있어야 한다. (RSA, 디피-헬만)</p>

<h4 id="일방향-암호-방식해시-암호-방식">일방향 암호 방식(해시 암호 방식)</h4>

<p>임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식</p>

<ul>
  <li>MAC: 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장</li>
  <li>MDC: 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장</li>
</ul>

<h4 id="대칭키-암호화-알고리즘">대칭키 암호화 알고리즘</h4>

<ul>
  <li>DES: 1975년 IBM 개발, 대칭 키 기반</li>
  <li>SEED: 1999년 한국인터넷진흥원(KISA) 개발</li>
  <li>AES: 2001년 미국 표준기술 연구소(NIST) 개발</li>
  <li>ARIA: 2004년 국가정보원과 산학연구협회가 개발</li>
  <li>IDEA: DES 대체, 스위스 연방기술기관 개발</li>
  <li>LFSR: 선형함수로 계산되는 구조로 되어있는 스트임 암호화 알고리즘</li>
</ul>

<h4 id="비대칭-키-암호화-알고리즘">비대칭 키 암호화 알고리즘</h4>

<ul>
  <li>디피-헬만: 최초의 공개키 알고리즘</li>
  <li>RSA: 1977년 MIT 개발</li>
  <li>ElGamal: 1984년 ElGamal 개발</li>
  <li>ECC: 1985년 RSA 대안으로 개발</li>
</ul>

<h4 id="해시-암호화-알고리즘">해시 암호화 알고리즘</h4>

<ul>
  <li>MD5: MD4 개선한 암호화 알고리즘, 파일의 무결성 검사에 사용</li>
  <li>SHA-1: 1993년 NSA에 미국 정부 표준 지정</li>
  <li>SHA-256/384/512: 256비트의 해시값을 생성하는 해시함수</li>
  <li>HAS-160: 국내 표준 서명 알고리즘</li>
  <li>HAVAL: 메시지를 1024bits 블록으로 나눔</li>
</ul>

<h4 id="ipsecinternet-protocol-security">IPSec(Internet Protocol Security)</h4>

<p>무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜</p>

<h4 id="sslsecure-socket-layertlstransport-layer-security">SSL(Secure Socket Layer)/TLS(Transport Layer Security)</h4>

<p>클라이언트와 서버간의 웹데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜</p>

<h4 id="s-httpsecure-hypertexrt-transfer-protocol">S-HTTP(Secure Hypertexrt Transfer Protocol)</h4>

<p>웹상에서 네트워크 트래픽을 암호화 하는 방법</p>

<h3 id="소프트웨어-개발-보안-구현">소프트웨어 개발 보안 구현</h3>

<h4 id="시큐어-코딩-가이드">시큐어 코딩 가이드</h4>

<p>설계 및 구현 단계에서 해킹 등의 공격을 유발할 가능성이 있는 잠재적인 보안 취약점을 사전에 제거하고, 외부 공격으로부터 안전한 소프트웨어를 개발하는 기법</p>

<ul>
  <li>보안 취약점: 운영 단계의 보안 리스크</li>
  <li>보안 약점: 개발 단계의 보안 리스크</li>
</ul>

<h4 id="입력-데이터-검증-및-표현">입력 데이터 검증 및 표현</h4>

<p>입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목</p>

<h4 id="입력-데이터-검증-및-표현-취약점">입력 데이터 검증 및 표현 취약점</h4>

<ul>
  <li>XSS(Cross Site Script): 검증되지 않은 외부 입력 데이터가 포함된 웹페이지를 사용자가 열람함으로써 웹페이제 포함된 부적절한 스크립트가 실행되는 공격
    <ul>
      <li>대책: 특수문자 필터링, HTML태그 사용금지</li>
    </ul>
  </li>
  <li>사이트 간 요청 위조(CSRF: Cross-Site REquest Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
    <ul>
      <li>대책: 입력화면 폼 POS방식 사용, 세션별 CSRF토큰 사용</li>
    </ul>
  </li>
  <li>SQL 삽입(Injection): 악의적인 SQL구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격
    <ul>
      <li>대책: 변수 타입 지정, 사용자 입력값 모두 체크하여 필터링</li>
    </ul>
  </li>
</ul>

<h4 id="보안-기능">보안 기능</h4>

<p>소프트웨어 개발 단계에서 인증, 접근제어, 기밀성, 암호화, 권한 관리 등을 적절하게 구현하기 위한 보안 점검 항목</p>

<h4 id="에러-처리">에러 처리</h4>

<p>프로그램 실행시 발생하는 에러를 예외 처리하지 못하거나, 에러에 중요한 정보가 포함될 때 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목</p>

<h4 id="세션-통제">세션 통제</h4>

<p>세션과 관련되어 발생할 수 있는 취약점을 예방하기 위한 보안 점검 항목</p>

<h4 id="코드-오류">코드 오류</h4>

<p>개발자의 실수로 발생하는 프로그램 오류를 예방하기 위한 보안 점검 항목</p>

<h4 id="캡슐화">캡슐화</h4>

<p>외부에 은닉이 필요한 중요한 데이터와 인가되지 않은 사용자에게 노출되지 않게 보안 취약점을 예방을 위한 보안 검증 항목</p>

<h4 id="api-오용">API 오용</h4>

<p>보안에 취약한 API를 오용하여 발생할 수 있느 보안 취약점 예방을 위한 보안 검증 항목</p>

<h4 id="네트워크-보안-솔루션">네트워크 보안 솔루션</h4>

<ul>
  <li>방화벽(Firewall) : 기업 내부, 외부 간 트래픽을 모니터링 하여 시스템의 접근을 허용/차단하는 시스템</li>
  <li>웹 방화벽 (WAF: Web Application Firewall): 웹 애플리케이션 보안에 특화된 보안 장비</li>
  <li>네트워크 접근 제어(NAC: Network Access Control) : 단말기가 내부 네트워크에 접속을 시도할 때 이를 제어하고 통제하는 기능을 제공하는 솔루션</li>
  <li>침입 탐지 시스템(IDS: Intrusion Detection System) : 네트워크에 발생하는 이벤트를 모니터링하고, 보안정책 위반 행위를 실시간으로 탐지하는 시스템</li>
  <li>침입 방지 시스템(IPS: Intrusion Prevention System) : 네트워크에 대한 공격이나 침입을 실시간적으로 차단하고, 유해드래칙에 대해 능동적으로 조치하는 시스템</li>
  <li>무선 침입 방지 시스템(WIPS: Wireless Intrusion Prevention System) : 무선 단말기의 접속을 자동 탐지 및 차단하고 보안에 취약한 무선 공유기를 탐지하는 시스템</li>
  <li>통합 보안 시스템(UTM: Unified Threat Management) : 다양한 보안 장비의 기능을 하나의 장비로 통합하여 제공하는 시스템</li>
  <li>가상사설망(VPN: Virtual Private Network) : 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용해 마치 전용망을 사용하는 효과를 가지는 보안 솔루션</li>
</ul>

<h4 id="시스템-보안-솔루션">시스템 보안 솔루션</h4>

<ul>
  <li>스팸 차단 솔루션(Anti-Spam Solution): 매일 서버 앞단에 위칳하여 Proxy 메일 서버로 동작</li>
  <li>보안 운영체제(Secure OS): 컴퓨터 운영체제의 커널에 보안기능을 추가한 솔루션</li>
</ul>

<h4 id="콜텐츠-유출-방지-솔루션">콜텐츠 유출 방지 솔루션</h4>

<ul>
  <li>보안 USB: 정보 유출 방지 등의 보안 기능을 갖춘 USB메모리</li>
  <li>데이터 유출 방지(DLP: Data Loss Prevention): 조직 내부의 중요 자료가 외부로 빠져나가는 것을 탐지하고 차단하는 솔루션</li>
  <li>디지털 저작권 관리(DRM): 디지털 저작물에 대한 보호와 관리를 위한 솔루션</li>
</ul>

<h4 id="소프트웨어-개발-보안테스트-유형">소프트웨어 개발 보안테스트 유형</h4>

<ul>
  <li>정적 분석: SW를 실행하지 않고 보안 약점을 분석, 개발 단계</li>
  <li>동적 분석: SW를 실행환경에서 보안 약점 분석, 시험 단계</li>
</ul>

<h4 id="비즈니스-연속성-계획bcp-busniess-continuity-plan">비즈니스 연속성 계획(BCP: Busniess Continuity Plan)</h4>

<p>각종 재해, 장애, 재난으로부터 위기관리 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 비즈니스 연속성을 보장하는 체계</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="software" /><category term="소프트웨어" /><category term="보안" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 소프트웨어 개발 보안 구축]]></summary></entry></feed>