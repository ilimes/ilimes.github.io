<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-30T19:54:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ilimes</title><subtitle>**공부하고 기록하는** 블로그 입니다.</subtitle><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><entry><title type="html">작업 효율을 높여주는 피그마(figma) 단축키 모음</title><link href="http://localhost:4000/figma/post17/" rel="alternate" type="text/html" title="작업 효율을 높여주는 피그마(figma) 단축키 모음" /><published>2022-07-27T00:00:00+09:00</published><updated>2022-07-27T00:00:00+09:00</updated><id>http://localhost:4000/figma/post17</id><content type="html" xml:base="http://localhost:4000/figma/post17/"><![CDATA[<p>피그마로 작업 할 때 조금이라도 작업 효율을 높이고 싶다면 단축키를 활용하는 것이 좋습니다. 요즘 피그마 작업을 하면서 단축키를 활용하려고 하는데 자주 사용하지 않으면 자꾸만 까먹게 되더라고요. 이번 포스팅은 제가 다시 보기 위해서 작성하게 된 피그마 단축키 모음입니다 😊</p>

<h3 id="전체-피그마-단축키-보는-법">전체 피그마 단축키 보는 법</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">?</code></li>
</ul>

<h3 id="그리드">그리드</h3>

<ul>
  <li>레이아웃 그리드 보기 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">4</code></li>
</ul>

<h3 id="컴포넌트">컴포넌트</h3>

<ul>
  <li>컴포넌트 생성 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">K</code></li>
  <li>인스턴스 분리 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">B</code></li>
  <li>오토레이아웃 생성 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">A</code></li>
  <li>오토레이아웃 제거 : <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">A</code></li>
  <li>컴포넌트 찾기/삽입 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">B</code></li>
  <li>컴포넌트명 한번에 수정 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">R</code></li>
  <li>만들어 놓은 객체 컴포넌트화 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">G</code></li>
</ul>

<h3 id="정리하기">정리하기</h3>

<ul>
  <li>앞으로 가져오기 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">]</code></li>
  <li>뒤로 보내기 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">[</code></li>
  <li>맨 앞으로 가져오기 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">]</code></li>
  <li>맨 뒤로 보내기 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">[</code></li>
</ul>

<h3 id="모양-변형">모양 변형</h3>

<ul>
  <li>가로로 뒤집기 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">V</code></li>
  <li>세로로 뒤집기 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">H</code></li>
  <li>아웃라인 스트로크 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">O</code></li>
</ul>

<h3 id="레이어">레이어</h3>

<ul>
  <li>전체화면에서 레이어 선택 : <code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Alt</code> 누른 상태에서 객체 클릭</li>
  <li>모든 레이어 닫기 : <code class="language-plaintext highlighter-rouge">Alt</code> + <code class="language-plaintext highlighter-rouge">L</code></li>
</ul>

<h3 id="확대-및-축소">확대 및 축소</h3>

<ul>
  <li>화면에 캔버스 핏 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">1</code></li>
  <li>선택한 개체 확대 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">2</code></li>
  <li>배율 100%로 맞추기 : <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">0</code></li>
  <li>확대 : <code class="language-plaintext highlighter-rouge">+</code> 또는 <code class="language-plaintext highlighter-rouge">Z</code>를 누른 채 클릭</li>
  <li>축소 : <code class="language-plaintext highlighter-rouge">-</code> 또는 <code class="language-plaintext highlighter-rouge">Z</code>와 <code class="language-plaintext highlighter-rouge">Alt</code>키를 누른 채 클릭</li>
</ul>

<h3 id="불투명도-설정">불투명도 설정</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0</code> ~ <code class="language-plaintext highlighter-rouge">9</code> 숫자키
    <ul>
      <li>특정 요소를 선택한 상태에서 숫자키를 사용하면 빠르게 불투명도 설정을 할 수 있습니다.<br />
보다 세밀하게 조정하고 싶다면 두 숫자를 연속으로 빠르게 입력하면 됩니다.</li>
    </ul>
  </li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Figma" /><category term="피그마" /><category term="figma" /><category term="디자인" /><category term="피그마단축키" /><category term="design" /><summary type="html"><![CDATA[알아두면 좋은 피그마 단축키 모음 입니다 :)]]></summary></entry><entry><title type="html">MongoDB란?</title><link href="http://localhost:4000/mongodb/post16/" rel="alternate" type="text/html" title="MongoDB란?" /><published>2022-07-26T00:00:00+09:00</published><updated>2022-07-26T00:00:00+09:00</updated><id>http://localhost:4000/mongodb/post16</id><content type="html" xml:base="http://localhost:4000/mongodb/post16/"><![CDATA[<h2 id="mongodb란">MongoDB란?</h2>

<p><code class="language-plaintext highlighter-rouge">MongoDB</code>란 데이터를 저장하는 데이터베이스 시스템의 한 종류로, 전통적인 테이블-관계 기반의 RDBMS가 아닌 도큐먼트 지향 NoSQL 데이터베이스 시스템입니다.</p>

<p><img width="580" alt="image" src="https://user-images.githubusercontent.com/95404736/181020729-0b97ae8d-31e8-4ef0-843e-ba05d84a30a0.png" /></p>

<h2 id="mongodb의-특징">MongoDB의 특징</h2>

<ul>
  <li>
    <h3 id="동적-스키마">동적 스키마</h3>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">MongoDB</code>는 테이블 구조가 고정되어 있는 형태(정적 스키마)가 아니라 JSON 형태의 동적 스키마형 문서를 사용합니다. 몽고디비에서는 그것을 Binary JSON(JavaScript Object Notaion)이라고 부르며, 줄여서 <code class="language-plaintext highlighter-rouge">BSON</code> 이라고 부르기도 합니다.</p>

<ul>
  <li>
    <h3 id="키-값의-집합-문서">키-값의 집합 문서</h3>
  </li>
</ul>

<p>앞서 작성한 특징과 비슷한데, 몽고 DB의 문서는 키-값의 집합으로 되어 있기 때문에 자바스크립트의 객체 코드와도 비슷한 형태로 되어 있습니다. 그래서 들어가는 데이터에 따라서 구조가 변경됩니다.</p>

<h2 id="mongodb의-장점">MongoDB의 장점</h2>

<ul>
  <li>
    <h3 id="퍼포먼스가-뛰어납니다">퍼포먼스가 뛰어납니다.</h3>

    <ul>
      <li>기본적으로 읽기 및 쓰기 성능이 뛰어나기 때문에 많은 트래픽을 감당할 때 사용해도 퍼포먼스가 뛰어납니다. 실제로 RDB보다 수십배는 빠른 성능을 발휘한다고 합니다.</li>
    </ul>
  </li>
  <li>
    <h3 id="개발이-편리합니다">개발이 편리합니다.</h3>
    <ul>
      <li>JSON 형태로 저장이 가능하기 때문에 직관적입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="mongodb의-단점">MongoDB의 단점</h2>

<ul>
  <li>
    <h3 id="조인이-없습니다">조인이 없습니다.</h3>

    <ul>
      <li>조인이 없기 때문에 데이터 구조화를 할 필요가 있습니다. <code class="language-plaintext highlighter-rouge">(MongoDB 3.2 버전 부터 보조적인 JOIN 기능으로 $lookup을 지원하기는 합니다.)</code> 외래키의 개념이 없으며 데이터 구조의 동적인 특성 때문에 몽고 DB의 데이터 모델링은 <code class="language-plaintext highlighter-rouge">역정규화(Denormalization)</code>로 흐르곤 합니다.</li>
    </ul>
  </li>
  <li>
    <h3 id="메모리에-의존적입니다">메모리에 의존적입니다.</h3>

    <ul>
      <li>데이터 갱신 시 바로 디스크에 쓰는 것이 아니라 논리적으로 메모리에 쓰고나서 일정 주기에 따라서 비동기식으로 쓰기 때문에 메모리에 의존적이며 때로는 데이터가 유실 될 가능성이 존재하기도 합니다. 메모리에 의존적이기 때문에 메모리 크기가 성능을 좌우합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="mongodb는-언제-쓰는-것이-좋을까">MongoDB는 언제 쓰는 것이 좋을까?</h2>

<p>Humongous(거대한) Database를 줄인 MongoDB라는 이름에서도 알 수 있듯이 MongoDB는 방대한 데이터 읽기가 필요한 경우에 사용하기 적합합니다. 로그성 데이터를 저장하는 경우, null 필드가 많이 존재하는 경우, 압도적인 퍼포먼스가 필요한 경우 등에 사용하기 좋습니다.</p>

<h2 id="today-i-learned">Today I Learned</h2>

<p>오늘은 MongoDB의 특징, 장단점 등 관련 정보를 공부하였습니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="MongoDB" /><category term="backend" /><category term="mongoDB" /><category term="몽고디비" /><category term="디비" /><category term="noSQL" /><summary type="html"><![CDATA[JSON과 같은 문서를 사용하여 대량의 데이터를 읽기 좋은 NoSQL 데이터베이스 MongoDB]]></summary></entry><entry><title type="html">POSTMAN이란?</title><link href="http://localhost:4000/web/post15/" rel="alternate" type="text/html" title="POSTMAN이란?" /><published>2022-07-18T00:00:00+09:00</published><updated>2022-07-18T00:00:00+09:00</updated><id>http://localhost:4000/web/post15</id><content type="html" xml:base="http://localhost:4000/web/post15/"><![CDATA[<h2 id="postman이란">POSTMAN이란?</h2>

<p><code class="language-plaintext highlighter-rouge">POSTMAN</code>은 API 개발을 보다 빠르고 쉽게 구현할 수 있도록 도와주며, 개발된 API를 테스트하여 문서화 또는 공유할 수 있게 해줍니다.</p>

<h2 id="postman을-사용하는-이유">POSTMAN을 사용하는 이유</h2>

<p><code class="language-plaintext highlighter-rouge">POSTMAN</code>을 사용하는 이유는 프론트엔드를 배제하고, 서버 프로그램이 들어온 API 요청에 대해서 제대로 동작하는지 확인하기 위함입니다. RESTful API 를 구현하다보면 특정 url에 파라미터나 헤더 등을 담아서 request를 보내는 테스트를 진행하게 되는데, 엄청나게 많이 반복되다보면 짜증이 날 수도 있습니다.</p>

<h2 id="restful-api의-개념">RESTful API의 개념</h2>

<p><code class="language-plaintext highlighter-rouge">RESTful API</code>란 HTTP URI(Uniform Resource Identifier)을 통하여 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통하여 해당 자원에 대한 CRUD를 적용하는 것을 의미합니다.</p>

<h2 id="postman-설치하기">POSTMAN 설치하기</h2>

<p><a href="https://www.postman.com/">https://www.postman.com/</a></p>

<p>POSTMAN을 설치하기 위해서는 위 주소로 이동하여 해당 운영체제에 맞는 버튼을 클릭하면 됩니다. 꽤나 간단하게 설치가 완료됩니다. 계정을 보유하고 있는 경우에는 요청 히스토리, 테스트 환경 등이 저장되어 있으니 그대로 사용할 수 있습니다.</p>

<h2 id="postman-장점">POSTMAN 장점</h2>

<ul>
  <li>툴이 꽤나 가볍다</li>
  <li>협업 시 팀원이 만든 url을 확인할 때 편하다</li>
  <li>RESTful API를 표현할 수 있다.</li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>

<p><a href="https://incheol-jung.gitbook.io/docs/q-and-a/infra/2018-01-03-how-to-use-postman">https://incheol-jung.gitbook.io/docs/q-and-a/infra/2018-01-03-how-to-use-postman</a></p>

<h2 id="today-i-learned">Today I Learned</h2>

<p>Postman을 사용하여 API 테스트를 할 수 있다는 것을 알게되었고, 번거로움을 해소해주는 아주 유용한 개발 툴이라는 생각을 하게 되었습니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Web" /><category term="API" /><category term="postman" /><category term="포스트맨" /><category term="개발" /><category term="restapi" /><summary type="html"><![CDATA[API 개발을 보다 빠르고 쉽게 구현 할 수 있도록 도와주는 POSTMAN]]></summary></entry><entry><title type="html">리액트 Hooks : useMemo()</title><link href="http://localhost:4000/react/post14/" rel="alternate" type="text/html" title="리액트 Hooks : useMemo()" /><published>2022-07-17T00:00:00+09:00</published><updated>2022-07-17T00:00:00+09:00</updated><id>http://localhost:4000/react/post14</id><content type="html" xml:base="http://localhost:4000/react/post14/"><![CDATA[<h2 id="memoization-이란">Memoization 이란?</h2>

<p><code class="language-plaintext highlighter-rouge">Memoization</code>은 프로그래밍 기법 중 하나로 기존에 수행한 연산의 결과값을 메모리에 저장해놓고 필요할 때 재사용하여 계산의 반복수행을 하지 않는 것입니다. 이런 기법을 사용하게 되면 중복 연산을 피할 수 있기 때문에 프로그램 실행 속도가 빨라지게 됩니다.</p>

<h2 id="usememo-란">useMemo() 란?</h2>

<p>리액트에서 함수형 컴포넌트는 <code class="language-plaintext highlighter-rouge">렌더링</code> -&gt; <code class="language-plaintext highlighter-rouge">Component 함수 호출</code> -&gt; <code class="language-plaintext highlighter-rouge">모든 내부 변수 초기화</code>의 순서를 거치게 됩니다. 이 때 무거운 연산을 하는 어떤 함수를 리렌더링이 될 때 마다 반복적으로 호출하게 된다면 효율성이 굉장히 떨어질 수 있는데요. 리액트에서 useMemo를 사용하면 <code class="language-plaintext highlighter-rouge">렌더링</code> -&gt; <code class="language-plaintext highlighter-rouge">Component 함수 호출</code> -&gt; <code class="language-plaintext highlighter-rouge">Memoize된 함수 재사용</code>의 순서를 거치게 됩니다. 이는 처음 계산된 결과값이 메모리에 저장되어서 컴포넌트가 리렌더링 될 때 계산된 결과값을 메모리에서 꺼내와서 재사용할 수 있는 것으로, 불필요한 연산을 없애고 성능을 더욱 최적화 할 수 있게 하는 것입니다. useMemo를 사용하게 되면 Memoization용 메모리가 필요하기 때문에 남용하는 것은 좋지 않습니다.</p>

<h2 id="usememo-사용-방법">useMemo 사용 방법</h2>

<ul>
  <li>import</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useMemo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>리액트에서 useMemo를 사용하기 위해서는 가장 먼저 위와 같이 react에서 useMemo를 import 해야합니다.</p>

<ul>
  <li>기본 형태</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 첫 번째 인자 콜백함수</span>
<span class="c1">// 두 번째 인자 의존성배열</span>
<span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">b</span><span class="p">]);</span>
</code></pre></div></div>

<p>useMemo의 기본 형태는 위와 같습니다.<br />
첫 번째 인자로는 콜백함수를, 두 번째로 인자로는 의존성배열을 받는데요. 두 번째 인자로 들어가는 배열 요소 값이 업데이트 될 때만 콜백함수를 다시 호출해서 연산하고, 값이 업데이트 되지 않으면 이전에 연산했던 값을 재사용하게 됩니다.</p>

<ul>
  <li>useMemo를 사용하지 않았을 때</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Practice</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">list</span><span class="p">,</span> <span class="nx">setList</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">setNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">calculate</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">계산중 입니다!</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="kd">const</span> <span class="nx">onChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setNumber</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">onInsert</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nextList</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">number</span><span class="p">));</span>
    <span class="nx">setList</span><span class="p">(</span><span class="nx">nextList</span><span class="p">);</span>
    <span class="nx">setNumber</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">input</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">number</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onInsert</span><span class="si">}</span><span class="p">&gt;</span>등록<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
          <span class="p">&lt;</span><span class="nt">li</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">index</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
        <span class="p">))</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>합계 :<span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;</span> <span class="si">{</span><span class="nx">calculate</span><span class="p">()</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Practice</span><span class="p">;</span>
</code></pre></div></div>

<p>위 코드는 useMemo를 사용하지 않고 만든 코드입니다. 이런 경우에는 최초, 글자 입력 시, 버튼 클릭 시에 모두 “계산중 입니다!” 라는 메시지가 콘솔에 찍히게 됩니다.</p>

<ul>
  <li>useMemo를 사용했을 때</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useMemo</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Practice</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">list</span><span class="p">,</span> <span class="nx">setList</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">setNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">calculate</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">계산중 입니다!</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">list</span><span class="p">]);</span>

  <span class="kd">const</span> <span class="nx">onChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setNumber</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">onInsert</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nextList</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">number</span><span class="p">));</span>
    <span class="nx">setList</span><span class="p">(</span><span class="nx">nextList</span><span class="p">);</span>
    <span class="nx">setNumber</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">input</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">number</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onInsert</span><span class="si">}</span><span class="p">&gt;</span>등록<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
          <span class="p">&lt;</span><span class="nt">li</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">index</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
        <span class="p">))</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>합계 :<span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;</span> <span class="si">{</span><span class="nx">calculate</span><span class="si">}</span>
        <span class="si">{</span><span class="cm">/* 여기서 calculate는 useMemo를 사용했기 때문에 값을 반환합니다 */</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Practice</span><span class="p">;</span>
</code></pre></div></div>

<p>위와 같이 useMemo를 사용한 경우에는 list가 업데이트 될 때만 렌더링하게 됩니다.</p>

<h2 id="today-i-learned">Today I Learned</h2>

<p>오늘은 리액트 Hooks 중에서 <code class="language-plaintext highlighter-rouge">useMemo</code>에 대해 공부했습니다. <code class="language-plaintext highlighter-rouge">useMemo</code>를 남용하면 메모리가 낭비되기도 하고, 평소 사용환경에서는 <code class="language-plaintext highlighter-rouge">useEffect</code>를 사용하여 비동기로 처리하는 경우가 많을 듯 하지만 <code class="language-plaintext highlighter-rouge">useMemo</code>는 알아놓으면 좋은 Hooks인 것 같습니다. 다음 번에는 <code class="language-plaintext highlighter-rouge">useMemo</code>와 유사한 <code class="language-plaintext highlighter-rouge">useCallback</code>에 대해 공부해보고 차이점은 무엇인지 알아봐야겠습니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="React" /><category term="useMemo" /><category term="react" /><category term="Hooks" /><category term="리액트" /><category term="Memoization" /><summary type="html"><![CDATA[성능 최적화를 위한 useMemo 사용법]]></summary></entry><entry><title type="html">Axios 알아보기(특징, 설치방법 문법 등)</title><link href="http://localhost:4000/nodejs/post13/" rel="alternate" type="text/html" title="Axios 알아보기(특징, 설치방법 문법 등)" /><published>2022-07-14T00:00:00+09:00</published><updated>2022-07-14T00:00:00+09:00</updated><id>http://localhost:4000/nodejs/post13</id><content type="html" xml:base="http://localhost:4000/nodejs/post13/"><![CDATA[<h2 id="axios란">Axios란?</h2>

<p>공식 문서에도 적혀있듯이 Axios는 <strong>Node.js와 브라우저를 위한 Promise 기반 HTTP 클라이언트</strong> 입니다. JavaScript에서 클라이언트와 서버 간 데이터를 주고받기 위해서 사용하는 비동기 HTTP 통신 방법 중에서는 Axios 뿐만 아니라 Ajax, Fetch 등이 있는데요. 제가 앞서 사용해보았던 Ajax는 보통 jQuery를 사용하여 보다 쉽게 요청을 처리 할 수 있지만 Promise 기반의 통신 기술이 아니었습니다. Axios 는 Promise(ES6) 기반 HTTP 통신 라이브러리이며 크로스 브라우징 최적화로 브라우저간 호환성이 뛰어난데요. 설치가 필요하다는 점만 빼면 Fetch 대비 편의성도 좋아서 통상적으로 React나 Vue.js와 같은 프론트 프레임워크를 사용할때는 Axios를 주로 사용합니다.</p>

<h2 id="axios-vs-fetch">Axios vs Fetch</h2>

<p>보통 자바스크립트에서는 원래 Fetch를 주로 사용했다고 하는데, 아무래도 built-in 라이브러리 특성상 기능면에서 Axios대비 부족함이 있어서 요즘은 Axios의 선호도가 더 높다고 합니다.</p>

<table>
  <thead>
    <tr>
      <th>Axios</th>
      <th>Fetch</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>써드파티 라이브러리로 설치가 필요</td>
      <td>현대 브라우저에 빌트인이라 설치 필요 없음</td>
    </tr>
    <tr>
      <td>XSRF 보호를 해준다</td>
      <td>별도 보호 없음</td>
    </tr>
    <tr>
      <td>data 속성을 사용</td>
      <td>body 속성을 사용</td>
    </tr>
    <tr>
      <td>data는 object를 포함한다</td>
      <td>body는 문자열화 되어있다</td>
    </tr>
    <tr>
      <td>status가 200이고 statusText가 ‘OK’이면 성공이다</td>
      <td>응답객체가 ok 속성을 포함하면 성공이다</td>
    </tr>
    <tr>
      <td>자동으로 JSON데이터 형식으로 변환된다</td>
      <td>.json()메서드를 사용해야 한다.</td>
    </tr>
    <tr>
      <td>요청을 취소할 수 있고 타임아웃을 걸 수 있다.</td>
      <td>해당 기능 존재 하지않음</td>
    </tr>
    <tr>
      <td>HTTP 요청을 가로챌수 있음</td>
      <td>기본적으로 제공하지 않음</td>
    </tr>
    <tr>
      <td>download진행에 대해 기본적인 지원을 함</td>
      <td>지원하지 않음</td>
    </tr>
    <tr>
      <td>좀더 많은 브라우저에 지원됨</td>
      <td>Chrome 42+, Firefox 39+, Edge 14+, and Safari 10.1+이상에 지원</td>
    </tr>
  </tbody>
</table>

<h2 id="axios-설치-방법">Axios 설치 방법</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install axios
</code></pre></div></div>

<p>Axios는 위와 같이 npm으로 간단하게 설치할 수 있습니다.</p>

<h2 id="axios-문법">Axios 문법</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">axios</span><span class="p">({</span>
  <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:3000</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 통신할 웹문서</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">get</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 통신 방식</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// 보낼 데이터</span>
    <span class="na">foo</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="axios-요청request-파라미터-옵션">Axios 요청(request) 파라미터 옵션</h2>

<p>자주 사용하는 옵션은 상단에 표시 및 위치하고 있습니다.<br />
대부분의 내용은 ‘인파_‘님 블로그(<a href="https://inpa.tistory.com/entry/AXIOS-%F0%9F%93%9A-%EC%84%A4%EC%B9%98-%EC%82%AC%EC%9A%A9">https://inpa.tistory.com/entry/AXIOS-%F0%9F%93%9A-%EC%84%A4%EC%B9%98-%EC%82%AC%EC%9A%A9</a>)에서 가져왔습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">method</code> : 요청 방식으로 기본값은 get입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">url</code> : 서버 주소</li>
  <li><code class="language-plaintext highlighter-rouge">headers</code> : 요청 헤더</li>
  <li><code class="language-plaintext highlighter-rouge">data</code> : 요청 방식이 ‘PUT’, ‘POST’, ‘PATCH’에 해당하는 경우에 body에 보내는 데이터</li>
  <li><code class="language-plaintext highlighter-rouge">params</code> : URL 파라미터 (?key=value로 요청하는 url get 방식을 객체로 표현 한 것)</li>
  <li><code class="language-plaintext highlighter-rouge">responseType</code> : 서버가 응답해주는 데이터의 타입 지정 (arraybuffer, documetn, json, text, stream, blob)</li>
  <li><code class="language-plaintext highlighter-rouge">withCredentials</code> : cross-site access-control 요청을 허용 유무. 이를 true로 하면 cross-origin으로 쿠키값을 전달 할 수 있습니다.</li>
  <li>baseURL : URL을 상대경로로 쓰는 경우에 URL 맨 앞에 붙는 주소<br />
ex) URL이 /post이고 baseURL이 https://some-domain.com/api/ 이면 https://some-domain.com/api/post 로 요청이 가게 됩니다.</li>
  <li>timeout : 요청 timeout이 발동 되기 전 milliseconds의 시간을 요청합니다. timeout 보다 요청이 길어진다면, 요청은 취소되게 됩니다.</li>
  <li>responseEncoding : 디코딩 응답에 사용하기 위한 인코딩 (utf-8)</li>
  <li>transformRequest : 서버에 전달되기 전에 요청 데이터를 바꿀 수 있습니다.
    <ul>
      <li>요청 방식 ‘PUT’, ‘POST’, ‘PATCH’, ‘DELETE’ 에 해당하는 경우에 이용 가능합니다.</li>
      <li>배열의 마지막 함수는 string 또는 Buffer, 또는 ArrayBuffer를 반환합니다.</li>
      <li>header 객체를 수정 가능합니다.</li>
    </ul>
  </li>
  <li>transformResponse : 응답 데이터가 만들어지기 전에 변환 가능</li>
  <li>auth : HTTP의 기본 인증에 사용합니다. auth를 통해서 HTTP의 기본 인증이 구성이 가능합니다.</li>
  <li>maxContentLength: http 응답 내용의 max 사이즈를 지정하도록 하는 옵션입니다.</li>
  <li>validateStatus : HTTP응답 상태 코드에 대해 promise의 반환 값이 resolve 또는 reject 할지 지정하도록 하는 옵션입니다.</li>
  <li>maxRedirects : node.js에서 사용되는 리다이렉트 최대치를 지정합니다.
httpAgent /  httpsAgent : node.js에서 http나 https를 요청을 할때 사용자 정의 agent를 정의하는 옵션입니다.</li>
  <li>proxy : proxy서버의 hostname과 port를 정의하는 옵션입니다.</li>
  <li>cancelToken : 요청을 취소하는데 사용되어 지는 취소토큰을 명시합니다.</li>
</ul>

<h2 id="axios-응답-스키마">Axios 응답 스키마</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{},</span> <span class="c1">// 서버가 제공한 응답(데이터)</span>
 
  <span class="na">status</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="c1">// `status`는 서버 응답의 HTTP 상태 코드</span>
  
  <span class="na">statusText</span><span class="p">:</span> <span class="dl">'</span><span class="s1">OK</span><span class="dl">'</span><span class="p">,</span>  <span class="c1">// `statusText`는 서버 응답으로 부터의 HTTP 상태 메시지</span>
 
  <span class="na">headers</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1">// `headers` 서버가 응답 한 헤더는 모든 헤더 이름이 소문자로 제공</span>
 
  <span class="na">config</span><span class="p">:</span> <span class="p">{},</span> <span class="c1">// `config`는 요청에 대해 `axios`에 설정된 구성(config)</span>
 
  <span class="na">request</span><span class="p">:</span> <span class="p">{}</span>
  <span class="c1">// `request`는 응답을 생성한 요청</span>
  <span class="c1">// 브라우저: XMLHttpRequest 인스턴스</span>
  <span class="c1">// Node.js: ClientRequest 인스턴스(리디렉션)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="axios-단축-메소드">Axios 단축 메소드</h2>

<p>axios 를 편리하게 사용할 수 있게하는 메소드입니다. (Ajax에서 <code class="language-plaintext highlighter-rouge">$.get()</code>이나 <code class="language-plaintext highlighter-rouge">$.post()</code> 같은 느낌)</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">axios</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span>
<span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">config</span><span class="p">])</span>
<span class="nx">axios</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">config</span><span class="p">])</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">head</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">config</span><span class="p">])</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">options</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">config</span><span class="p">])</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">data</span><span class="p">[,</span> <span class="nx">config</span><span class="p">]])</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">data</span><span class="p">[,</span> <span class="nx">config</span><span class="p">]])</span>
<span class="nx">axios</span><span class="p">.</span><span class="nx">patch</span><span class="p">(</span><span class="nx">url</span><span class="p">[,</span> <span class="nx">data</span><span class="p">[,</span> <span class="nx">config</span><span class="p">]])</span>
</code></pre></div></div>

<h2 id="axios-기본-사용법">Axios 기본 사용법</h2>

<ul>
  <li>기본 사용법</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">axios</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// ID로 사용자 요청</span>
<span class="nx">axios</span>
  <span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/user?ID=12345</span><span class="dl">'</span><span class="p">)</span>
  <span class="c1">// 응답(성공)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="c1">// 응답(실패)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="c1">// 응답(항상 실행)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
</code></pre></div></div>

<ul>
  <li>async와 await을 사용하여 보기 좋아진 코드</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">getUser</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/user?ID=12345</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="today-i-learned">Today I Learned</h2>

<p>오늘은 <code class="language-plaintext highlighter-rouge">Axios</code>에 대해 공부했습니다. 기본적인 사용 방법을 알게 되었고, 빌트인으로 <code class="language-plaintext highlighter-rouge">fetch</code>가 있어도 <code class="language-plaintext highlighter-rouge">Axios</code>가 기능이 다양해서 선호된다는 것도 알게되었습니다. 앞으로 사용하게 될 일이 많을 것 같은데 생각보다 활용하는 방법이 무궁무진 한 것 같아서 잘 정리해놓고 활용해봐야겠습니다 :)</p>

<h3 id="참고사이트">참고사이트</h3>

<ul>
  <li><a href="https://inpa.tistory.com/entry/AXIOS-%F0%9F%93%9A-%EC%84%A4%EC%B9%98-%EC%82%AC%EC%9A%A9">https://inpa.tistory.com/entry/AXIOS-%F0%9F%93%9A-%EC%84%A4%EC%B9%98-%EC%82%AC%EC%9A%A9</a></li>
  <li><a href="https://axios-http.com/kr/docs/intro">https://axios-http.com/kr/docs/intro</a></li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="NodeJs" /><category term="axios" /><category term="Node.js" /><category term="NodeJS" /><category term="AJAX" /><category term="Promise" /><category term="비동기" /><summary type="html"><![CDATA[HTTP 비동기 통신 라이브러리 - Axios]]></summary></entry><entry><title type="html">Mac에서 MariaDB 및 GUI 툴 설치하기</title><link href="http://localhost:4000/web/post12/" rel="alternate" type="text/html" title="Mac에서 MariaDB 및 GUI 툴 설치하기" /><published>2022-07-12T00:00:00+09:00</published><updated>2022-07-12T00:00:00+09:00</updated><id>http://localhost:4000/web/post12</id><content type="html" xml:base="http://localhost:4000/web/post12/"><![CDATA[<p>회사에 사용하는 데이터베이스가 MariaDB라서 집에서도 DB공부를 진행해보고자 개인 PC에 MariaDB를 설치해보았습니다.</p>

<h2 id="mac에서-mariadb-설치하기">Mac에서 MariaDB 설치하기</h2>

<p><a href="https://mariadb.org/download/?t=mariadb&amp;p=mariadb&amp;r=10.4.25">https://mariadb.org/download/?t=mariadb&amp;p=mariadb&amp;r=10.4.25</a><br />
위 링크는 MariaDB 서버를 설치파일로 다운로드 받을 수 있는 페이지로 이동하는 링크입니다. 들어가서 확인해보시면 아시겠지만 MariaDB는 Mac전용 설치파일을 지원하지 않습니다. 그래서 저는 homebrew 를 이용하여 MariaDB를 설치 하였습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install mariadb
</code></pre></div></div>

<p>homebrew가 설치되어 있지 않다면 우선적으로 설치를 해주시고, homebrew 설치가 완료되었다면 터미널에 위 명령어를 입력하시면 됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arch -arm64 brew install mariadb
</code></pre></div></div>

<p>저같은 경우는 M1 Mac을 사용중이라 위 명령어를 입력하여 설치를 진행하였습니다.</p>

<h2 id="homebrew로-mariadb-시작하기">homebrew로 MariaDB 시작하기</h2>

<p>일반적인 설치를 한 경우에는 db 서버를 시작하는 명령어가 <code class="language-plaintext highlighter-rouge">mysql.server.start</code> 인데 homebrew로 MariaDB를 설치 한 경우에는 아래와 같이 조금 다른 명령어로 서비스를 시작할 수 있습니다.</p>

<ul>
  <li>DB 서비스 시작</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services start mariadb
</code></pre></div></div>

<ul>
  <li>DB 서비스 중지</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services stop mariadb
</code></pre></div></div>

<ul>
  <li>DB 서비스 상태 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services list
</code></pre></div></div>

<h2 id="gui-툴-설치하기">GUI 툴 설치하기</h2>

<p>회사 컴퓨터는 윈도우 환경이라 HeidiSQL을 사용할 수 있었지만 Mac에서는 아쉽게도 HeidiSQL을 사용할 수 없더라고요. 그래서 대안으로 사용할 수 있는 툴을 찾아보았는데요. 꽤나 평이 좋은 툴인 Sequel Pro 를 발견하였습니다.</p>

<p><a href="https://sequelpro.com/">https://sequelpro.com/</a><br />
설치 방법은 아주 간단합니다. 위 링크에 접속하여 DOWNLOAD 버튼을 누르면 손쉽게 dmg 파일을 다운로드 받을 수 있습니다.
<br /><br />
<img width="992" alt="image" src="https://user-images.githubusercontent.com/95404736/178505172-1f35a13c-79a2-4662-84b3-85583837cd7c.png" /><br />
<br />
프로그램을 실행하면 위와 같은 화면이 뜨게되는데 원하는대로 Name, Host, Username, Password 등을 입력하면 됩니다. Name은 나에게 보여지는 이름이라 아무렇게나 적어도 되구요. 저같은 경우는 로컬에서 접속할거라 Host에 127.0.0.1 을 입력해주었습니다.</p>

<p>이렇게 PC에 MariaDB를 설치하고 GUI 툴까지 설치를 완료하였습니다. 앞으로 집에서도 DB 공부를 열심히 해봐야겠습니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Web" /><category term="MariaDB" /><category term="SequelPro" /><category term="db" /><summary type="html"><![CDATA[homebrew로 mariaDB를 설치하고 GUI툴인 sequel pro까지 설치하기]]></summary></entry><entry><title type="html">Node.js-Express</title><link href="http://localhost:4000/nodejs/post11/" rel="alternate" type="text/html" title="Node.js-Express" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/nodejs/post11</id><content type="html" xml:base="http://localhost:4000/nodejs/post11/"><![CDATA[<h2 id="express란">Express란?</h2>

<p><code class="language-plaintext highlighter-rouge">Express</code>란 Node.js 기반 웹 프레임워크로, 간단하게 서버 쪽 웹 어플리케이션을 쉽게 구현할 수 있도록 도와주는 프레임워크라고 할 수 있습니다.</p>

<h2 id="express-설치하기">Express 설치하기</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install express
</code></pre></div></div>

<p>Express를 설치하기 위해서는 위와 같이 npm 명령어를 사용하면 간단하게 설치할 수 있습니다.<br />
npm 명령어를 사용하기 이전에 Node.js와 npm init 실행이 반드시 선행되어야 합니다.</p>

<h2 id="express-5가지-개념">Express 5가지 개념</h2>

<p><code class="language-plaintext highlighter-rouge">[어플리케이션]</code></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">express</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>위와 같은 익스프레스 인스턴스를 어플리케이션이라고 합니다.</li>
  <li>listen 함수를 사용하여 서버를 요청 대기 상태로 만들 수 있습니다.</li>
  <li>라우팅 설정을 할 수 있습니다.</li>
  <li>서버에 필요한 미들웨어를 어플리케이션에 추가합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[미들웨어]</code></p>

<ul>
  <li>함수들의 연속</li>
  <li>미들웨어 추가 시 use 함수를 사용합니다.</li>
  <li>미들웨어는 반드시 인자로 req, res, next를 가져야합니다.</li>
  <li>미들웨어는 보통 <code class="language-plaintext highlighter-rouge">일반 미들웨어</code>와 <code class="language-plaintext highlighter-rouge">에러 미들웨어</code>로 나뉘는데 일반 미들웨어 같은 경우는 인자를 3개 받으며, 에러 미들웨어 같은 경우는 err, req, res, next 로 인자 4개를 가집니다.</li>
  <li>미들웨어는 본인이 할 일을 다 한 다음에 꼭 next() 함수를 호출해줘야 합니다. 만약 next() 없이 작성을 하게 된다면 다음 요청을 읽지 못해서 계속 대기 상태로 서버가 유지됩니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[라우팅]</code></p>

<ul>
  <li>요청 url에 대해서 적절한 핸들러 함수로 연결해주는 기능을 라우팅이라고 합니다.</li>
  <li>어플리케이션의 <code class="language-plaintext highlighter-rouge">get()</code>, <code class="language-plaintext highlighter-rouge">post()</code> 메소드로 구현할 수 있습니다.</li>
  <li>또한 라우팅을 위한 전용 Router 클래스를 사용할 수도 있습니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[요청객체 -&gt; req]</code></p>

<ul>
  <li>클라이언트의 요청 정보를 담은 객체를 요청객체라고 합니다. (http 모듈의 request 객체를 래핑)</li>
  <li>주로 <code class="language-plaintext highlighter-rouge">req.params()</code>, <code class="language-plaintext highlighter-rouge">req.query()</code>, <code class="language-plaintext highlighter-rouge">req.body()</code> 메소드를 사용합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">[응답객체 -&gt; res]</code></p>

<ul>
  <li>클라이언트의 응답 정보를 담은 객체를 응답객체라고 합니다. (http 모듈의 response 객체를 래핑)</li>
  <li>주로 <code class="language-plaintext highlighter-rouge">res.send()</code>, <code class="language-plaintext highlighter-rouge">res.status()</code>, <code class="language-plaintext highlighter-rouge">res.json()</code> 과 같은 함수를 사용할 수 있는데, <code class="language-plaintext highlighter-rouge">res.send()</code>는 문자열을 응답하는 함수이고 <code class="language-plaintext highlighter-rouge">res.status()</code>는 http 상태 코드를 응답하며, <code class="language-plaintext highlighter-rouge">res.json()</code>은 json 데이터를 응답합니다.</li>
</ul>

<h2 id="express-사용하기">Express 사용하기</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">express</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">port</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>

<span class="c1">// 메인 페이지에 접속했을 때 콜백함수 실행</span>
<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello World!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// hi 페이지에 접속했을 때 콜백함수 실행</span>
<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">/hi</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">&lt;h2&gt;Hi!&lt;/h2&gt;</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Example app listening at http://localhost:</span><span class="p">${</span><span class="nx">port</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<ul>
  <li>위 코드에서 보이는 <code class="language-plaintext highlighter-rouge">get()</code> 메소드는 <code class="language-plaintext highlighter-rouge">라우터</code>라고 하며 어떠한 요청이 들어오면 그것을 처리해주는 역할을 합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">send()</code> 라는 함수는 클라이언트에 보내는 역할을 하며, html 요소가 인수로 들어갈 수 있습니다.</li>
</ul>

<h2 id="today-i-learned">Today I Learned</h2>

<p>오늘은 Node.js 기반 웹 프레임워크 Express가 무엇인지 알게되었고, 간단한 사용 방법을 익혔습니다.
스프링으로 백엔드 개발을 하다가 자바스크립트로 서버를 공부하니 신기한 것이 정말 많은 것 같네요.
앞으로 백엔드 작업을 할 때 Express를 많이 사용하게 될 것 같은데, 블로그에 꾸준히 정리하면서 열심히 익혀야겠습니다 😊</p>

<h3 id="참고-사이트">참고 사이트</h3>

<p><a href="https://expressjs.com/">https://expressjs.com/</a></p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="NodeJs" /><category term="express" /><category term="NodeJs" /><category term="Node.js" /><summary type="html"><![CDATA[Node.js 기반 웹 프레임워크 Express에 대해 공부하기 + 간단한 사용]]></summary></entry><entry><title type="html">Git 기본 CLI 명령어 정리</title><link href="http://localhost:4000/git/post10/" rel="alternate" type="text/html" title="Git 기본 CLI 명령어 정리" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/git/post10</id><content type="html" xml:base="http://localhost:4000/git/post10/"><![CDATA[<h2 id="git-이란">Git 이란?</h2>

<p><code class="language-plaintext highlighter-rouge">Git</code>이란 형상 관리 도구중 하나로 버전 관리, 백업, 협업 등을 할 수 있는 강력한 도구입니다. Git은 중앙 서버에서 소스코드와 히스토리를 저장하던 SVN과는 달리 소스코드를 여러 개발 PC에 분산 저장하여 관리하는 시스템이라 SVN보다 속도가 더욱 빠르기도 하여 SVN을 사용하던 기존 개발 조직에서도 계속 Git으로 갈아타고 있는 추세입니다.</p>

<h2 id="cli란">CLI란?</h2>

<p><code class="language-plaintext highlighter-rouge">CLI</code>란 Command Line Interface의 약자로 텍스트 터미널을 통해 사용자와 컴퓨터가 상호작용하는 방식을 뜻합니다. 요즘은 GUI가 잘 되어있어서 반드시 CLI 방식으로만 Git을 사용해야만 하는 것은 아니지만 자주 사용하고 익숙해지면 편하고 빠르게 Git을 다룰 수 있어서 대부분의 개발자분들이 CLI방식으로 깃을 사용하고 있습니다.</p>

<h2 id="cli-명령어">CLI 명령어</h2>

<p>[폴더 이동 관련]</p>

<p><code class="language-plaintext highlighter-rouge">cd 폴더 경로</code> : 해당 위치 경로 폴더로 이동 (cd 절대경로 가능)<br />
<code class="language-plaintext highlighter-rouge">cd ..</code> : 이전 폴더(상위 디렉토리)로 이동<br />
<code class="language-plaintext highlighter-rouge">cd ~</code> : 홈 디렉토리로 이동<br />
<code class="language-plaintext highlighter-rouge">dir</code> : 현재 위치 내의 모든 파일을 표시<br />
<code class="language-plaintext highlighter-rouge">ls</code>: list의 약자로 현재 위치 폴더에 어떤 파일이나 디렉토리가 존재하는지 알려줌</p>

<ul>
  <li>ls 명령어 옵션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-a</code> : 숨김 파일과 디렉토리 모두 표시</li>
      <li><code class="language-plaintext highlighter-rouge">-l</code> : 파일이나 디렉토리 상세 정보 모두 표시</li>
      <li><code class="language-plaintext highlighter-rouge">-r</code> : 파일 정렬 순서를 거꾸로 표시</li>
      <li><code class="language-plaintext highlighter-rouge">-t</code> : 파일의 작성 시간 순서를 내림차순으로 표시</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">pwd</code> : 현재 작업 폴더 위치</p>

<p>[파일 생성 및 삭제 관련]</p>

<p>** 파일</p>

<p><code class="language-plaintext highlighter-rouge">touch 파일명</code> : 파일 생성<br />
<code class="language-plaintext highlighter-rouge">echo 문자열 &gt; 파일명</code> : 새로운 파일 생성하면서 문자열 삽입<br />
<code class="language-plaintext highlighter-rouge">rm 파일명</code> : 파일 삭제<br />
<code class="language-plaintext highlighter-rouge">cp 파일명 위치</code> : 파일 복사<br />
<code class="language-plaintext highlighter-rouge">mv 파일명 변경파일명</code> : 파일명 변경</p>

<p>** 폴더</p>

<p><code class="language-plaintext highlighter-rouge">mkdir 폴더명</code> : 새로운 폴더 생성<br />
<code class="language-plaintext highlighter-rouge">rm -r 폴더명</code> : 폴더 삭제
<code class="language-plaintext highlighter-rouge">cp -r 폴더명 위치</code> : 폴더 복사
<code class="language-plaintext highlighter-rouge">mv 폴더명 변경폴더명</code> : 폴더명 변경</p>

<h2 id="git-기본-명령어">Git 기본 명령어</h2>

<p>[Git 폴더 초기화]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init //버전 관리를 위한 기본 폴더를 생성하는 명령어
</code></pre></div></div>

<p>[Git 상태 확인]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git status //현재 상태 출력
git log //현재 커밋 로그 등을 출력
</code></pre></div></div>

<p>[Github에 업로드]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//업로드할 파일 추가
git add 파일명
git add .

//커밋
git commit -m '커밋 메시지'

//최신 커밋 메시지 수정
git commit --amend

//커밋 복구 (히스토리 유지)
git revert 원상복구할 커밋아이디

//푸쉬
git push 저장소명 브랜치명
git push origin main
</code></pre></div></div>

<p>[브랜치 관련]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//저장소 확인
git remote

//모든 브랜치 확인, 현재 브랜치는 다른 색이 표시됨
git branch

//새로운 브랜치 생성
git branch 브랜치명

//브랜치 이동
git checkout 브랜치명

//해당 브랜치가 합쳐짐
git merge 합쳐질 브랜치명
</code></pre></div></div>

<p>[그 외]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//커밋되기 전의 수정 파일들 숨겨놓기
git stash

//숨겨놓은 파일 리스트 보기
git stash -list

//원격 저장소 복제
git clone 원격 저장소 주소
</code></pre></div></div>

<h2 id="today-i-learned">Today I Learned</h2>

<p>이번 포스팅에서는 기본적인 CLI 명령어들을 정리해보았습니다.<br />
아직까지 익숙하지 않지만 앞으로 계속 사용하다보면 금방 익숙해질 것 같네요 😊</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Git" /><category term="cli" /><category term="git" /><category term="github" /><summary type="html"><![CDATA[Git에서 사용하는 기본적인 명령어를 정리해보았습니다.]]></summary></entry><entry><title type="html">Node.js 프로세스 관리도구 pm2</title><link href="http://localhost:4000/nodejs/post9/" rel="alternate" type="text/html" title="Node.js 프로세스 관리도구 pm2" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/nodejs/post9</id><content type="html" xml:base="http://localhost:4000/nodejs/post9/"><![CDATA[<h2 id="pm2란">pm2란?</h2>

<p><code class="language-plaintext highlighter-rouge">pm2</code>란 Node.js 운영을 효율적이게 할 수 있게 하는 프로세스 관리도구인데요. 기본적으로 싱글스레드 기반이라 멀티스레딩이 불가능한 Node.js에서 멀티스레딩과 비슷하게 내부적으로 서버를 Fork해서 사용할 수 있도록 클러스터라는 기능을 제공하기도 하고 프로세스가 죽었을 때의 처리 등 직접 하나씩 하게 된다면 귀찮은 온갖 일들을 몽땅 관리해주는 강력한 도구입니다.</p>

<h2 id="pm2-설치-방법">pm2 설치 방법</h2>

<p>아래 명령어를 이용하여 전역설치를 해줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install pm2 -g
</code></pre></div></div>

<p>설치 할 때 뒤에 <code class="language-plaintext highlighter-rouge">-g</code>라는 옵션을 붙이는 이유는 pm2 명령어를 어떤 디렉토리에서든 사용할 수 있도록 하기 위함입니다.</p>

<h2 id="pm2-명령어">pm2 명령어</h2>

<ul>
  <li>프로세스 실행</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 start 시작하고자 하는 파일 명.js
</code></pre></div></div>

<ul>
  <li>실행중인 파일 리스트 보기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 list
</code></pre></div></div>

<ul>
  <li>상세 정보 보기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 show 파일명
</code></pre></div></div>

<ul>
  <li>프로세스 종료</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 stop 실행중인 파일 명.js
</code></pre></div></div>

<ul>
  <li>pm2 데몬 자체를 꺼버리기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 kill
</code></pre></div></div>

<p>(위에서 <code class="language-plaintext highlighter-rouge">stop</code>이라는 명령어를 사용하면 프로세스는 중지되지만 pm2가 여전히 관리하고 있는 상태가 됩니다. 데몬 자체를 꺼버리기 위해서는 <code class="language-plaintext highlighter-rouge">kill</code>명령어를 입력해야합니다.)</p>

<ul>
  <li>프로세스 재시작</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 restart 실행중인 파일 명.js
</code></pre></div></div>

<ul>
  <li>모니터링</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 monit
</code></pre></div></div>

<p>(모니터링 상태에서는 pm2로 관리되는 프로세스별 상태를 볼 수 있고 실시간으로 로그를 확인하는 것이 가능합니다. 모니터링 상태에서 빠져나오기 위해서는 키보드의 <code class="language-plaintext highlighter-rouge">q</code>키를 누르면 됩니다.)</p>

<ul>
  <li>자동 재시작 설정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 start 실행하고자 하는 파일 명.js --watch
</code></pre></div></div>

<p>(위와 같이 watch 옵션을 추가하게 되면 pm2에서 파일 변경을 파악하고 자동 재시작을 해줍니다. node는 내용을 변경하고 나면 서버를 껐다가 다시 켜줘야만 변경사항이 반영되는데 자동 재시작을 해주기 때문에 굉장히 편리합니다.)</p>

<ul>
  <li>로그 보기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm2 log
</code></pre></div></div>

<h2 id="today-i-learned">Today I Learned</h2>

<p>이번 포스팅에서는 pm2에 대해서 공부한 내용들을 간단하게 정리해보았고,
기본적인 pm2 명령어들도 살펴보았습니다.</p>

<h3 id="참고-사이트">참고 사이트</h3>

<p><a href="https://pm2.keymetrics.io/">https://pm2.keymetrics.io/</a></p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="NodeJs" /><category term="pm2" /><category term="Node.js" /><summary type="html"><![CDATA[Node.js 운영을 효율적이게 하는 프로세스 관리도구]]></summary></entry><entry><title type="html">리액트에서 styled-components로 스타일링 하기</title><link href="http://localhost:4000/react/post8/" rel="alternate" type="text/html" title="리액트에서 styled-components로 스타일링 하기" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/react/post8</id><content type="html" xml:base="http://localhost:4000/react/post8/"><![CDATA[<h2 id="styled-components란">styled-components란?</h2>

<p>styled-component는 리액트에서 사용하는 대표적인 CSS-in-JS 라이브러리 입니다. 스타일을 자바스크립트 파일에 내장시켜 사용할 수 있으며 CSS 커스텀 컴포넌트를 만들어서 쉽게 재사용할 수 있습니다.</p>

<h2 id="styled-components-설치-방법">styled-components 설치 방법</h2>

<p>먼저 터미널에 아래 명령어를 입력하여 styled-components를 설치합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">npm</span> <span class="nx">install</span> <span class="nx">styled</span><span class="o">-</span><span class="nx">components</span>
</code></pre></div></div>

<p>그리고 적용하려는 components 파일 상단에 아래 한 줄을 import 합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">styled</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="styled-components-사용하기">styled-components 사용하기</h2>

<p>기본적인 사용방법은 아래와 같습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyStyle</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  color: blue;
`</span><span class="p">;</span>
</code></pre></div></div>

<p>위와 같이 고정된 blue 색상을 주는 MyStyle 컴포넌트를 만들어주도록 하겠습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">MyStyle</span><span class="p">&gt;</span>안녕하세요<span class="p">&lt;/</span><span class="nc">MyStyle</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>해당 컴포넌트를 사용하면 아래와 같은 실행결과를 얻을 수 있습니다.</p>

<ul>
  <li>실행 결과<br />
<img src="https://user-images.githubusercontent.com/95404736/177561605-f41b5eb0-afff-4353-aa7f-e2e0296ac044.png" alt="image" /></li>
</ul>

<p>이렇게 고정적인 스타일링을 하는 것은 좋은 예가 아닙니다. 이렇게 만들게 되면 색을 바꾸고 싶을 때 마다 새로운 컴포넌트를 계속 만들어줘야 합니다.</p>

<p>그래서 좀 더 효율적으로 컴포넌트를 만들기 위해서는 props를 잘 활용해야 하는데요. props를 활용한 예는 아래와 같습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyStyle</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  color: </span><span class="p">${(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">props</span><span class="p">.</span><span class="nx">myColor</span><span class="p">}</span><span class="s2">;
`</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">MyStyle</span> <span class="na">myColor</span><span class="p">=</span><span class="s">"red"</span><span class="p">&gt;</span>안녕하세요<span class="p">&lt;/</span><span class="nc">MyStyle</span><span class="p">&gt;</span>
</code></pre></div></div>

<ul>
  <li>실행 결과<br />
<img src="https://user-images.githubusercontent.com/95404736/177562898-889181a8-85c1-4dc5-b21e-0046e010ac38.png" alt="image" /></li>
</ul>

<h2 id="styled-components를-사용해서-antd-스위치-스타일-바꿔보기">styled-components를 사용해서 AntD 스위치 스타일 바꿔보기</h2>

<p>직접 만든 컴포넌트 뿐만 아니라 AntD와 styled-components를 함께 사용할 수 있습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Switch</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">antd</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">antd/dist/antd.css</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">styled</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">./App.css</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">StyledSwitch</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">(</span><span class="nx">Switch</span><span class="p">)</span><span class="s2">`
  &amp;[aria-checked="true"] {
    background: green;
  }
  &amp;[aria-checked="false"] {
    background: red;
  }
`</span><span class="p">;</span>
</code></pre></div></div>

<p>위 코드에서 &amp;은 부모 선택자입니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">StyledSwitch</span> <span class="na">checkedChildren</span><span class="p">=</span><span class="s">"ON"</span> <span class="na">unCheckedChildren</span><span class="p">=</span><span class="s">"OFF"</span> <span class="na">defaultChecked</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>스위치 ON 일 때<br />
<img src="https://user-images.githubusercontent.com/95404736/177559148-366341b3-f62f-4496-b499-77361ed403b3.png" alt="image" /></p>
  </li>
  <li>
    <p>스위치 OFF 일 때<br />
<img src="https://user-images.githubusercontent.com/95404736/177559214-2a2f587c-d72f-4b8d-9bd0-4afe93de5e97.png" alt="image" /></p>
  </li>
</ul>

<h2 id="today-i-learned">Today I Learned</h2>

<p>오늘은 리액트에서 styled-components로 스타일링 하는 방법에 대해 공부했습니다. AntD를 사용하다보면 앞으로 가끔씩 커스텀 스타일링을 하게 될 경우가 생길 듯 한데 오늘 공부한 내용을 잘 활용하면 좋을 것 같습니다 :)</p>

<h3 id="참고-사이트">참고 사이트</h3>

<p><a href="https://styled-components.com/docs">https://styled-components.com/docs</a></p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="React" /><category term="리액트" /><category term="react" /><category term="style" /><category term="css" /><category term="styled" /><category term="component" /><summary type="html"><![CDATA[React styled-components 사용법]]></summary></entry></feed>