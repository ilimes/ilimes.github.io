<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-13T23:08:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ilimes</title><subtitle>**공부하고 기록하는** 블로그</subtitle><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><entry><title type="html">스택(Stack)이란 무엇일까?</title><link href="http://localhost:4000/algorithm/post85/" rel="alternate" type="text/html" title="스택(Stack)이란 무엇일까?" /><published>2023-12-13T00:00:00+09:00</published><updated>2023-12-13T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/post85</id><content type="html" xml:base="http://localhost:4000/algorithm/post85/"><![CDATA[<p>이번 포스팅에서는 스택(Stack)이 무엇인지에 대해 간단하게 정리해보고자 합니다 :)</p>

<h3 id="스택stack이란">스택(Stack)이란?</h3>

<p>스택이란 말 그대로 <code class="language-plaintext highlighter-rouge">쌓아놓은 더미</code>를 뜻합니다. 스택은 프링글스 통을 떠올리면 쉽게 이해할 수 있는데요. 프링글스 통에 든 과자 내용물은 제조공정 상에서 주입이 될 것이고, 처음에 담기는 과자는 가장 아래쪽에 위치하게 될 것입니다. 결국 프링글스 과자를 구입하여 뜯은 뒤 가장 먼저 먹게되는 과자 조각은 가장 마지막에 담은 과자가 되는 것입니다. 즉 입구와 출구가 같은 자료구조인 것이죠.</p>

<h3 id="스택stack의-특징">스택(Stack)의 특징</h3>

<h4 id="후입선출">후입선출</h4>

<p>스택의 특징으로는 후입선출(LIFO: Last In First Out) 방식이라는 점을 꼽을 수 있는데요. 후입선출이란 말 그대로 최근에 들어온 데이터가 가장 먼저 나가는 것을 뜻합니다.</p>

<h3 id="스택stack의-연산">스택(Stack)의 연산</h3>

<h4 id="삽입-연산---push">삽입 연산 - Push</h4>

<p>스택에 데이터를 넣기 위하여 수행하는 연산을 Push 연산 이라고 합니다.
Push 연산은 스택이 꽉 차기 전까지 수행되며, 스택이 가득차면 수행을 멈추게 됩니다.</p>

<ul>
  <li>Stack 영역의 메모리가 지정된 범위를 넘어갈 때 발생하는 것 -&gt; Stack Overflow</li>
</ul>

<h4 id="삭제-연산---pop">삭제 연산 - Pop</h4>

<p>Push 연산과 반대로 스택에 있는 데이터를 추출하기 위하여 수행하는 연산을 Pop 연산이라고 합니다.
Pop 연산은 스택이 비어있지 않을 때 까지 연산을 수행하며, 스택이 비어있다면 수행을 멈추게 됩니다.</p>

<h3 id="스택을-주로-사용하는-곳">스택을 주로 사용하는 곳</h3>

<ul>
  <li>웹 브라우저의 뒤로가기</li>
  <li>프로그램의 실행 취소(Undo)</li>
  <li>문자열 뒤집기</li>
  <li>수식 괄호 검사</li>
  <li>JVM 메모리</li>
</ul>

<p>위 뿐만 아니라 Stack은 다양한 곳에 개념을 적용하여 사용되고 있습니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Algorithm" /><category term="Algorithm" /><category term="자료구조" /><category term="스택" /><category term="Stack" /><summary type="html"><![CDATA[What is a Stack?]]></summary></entry><entry><title type="html">NVM default 노드 버전 변경 하는 방법</title><link href="http://localhost:4000/setting/post84/" rel="alternate" type="text/html" title="NVM default 노드 버전 변경 하는 방법" /><published>2023-10-31T00:00:00+09:00</published><updated>2023-10-31T00:00:00+09:00</updated><id>http://localhost:4000/setting/post84</id><content type="html" xml:base="http://localhost:4000/setting/post84/"><![CDATA[<p>오늘은 nvm에서 기본(default) 노드 버전을 변경하는 방법을 간단하게 소개해드리도록 하겠습니다 :)</p>

<h3 id="nvm-list-확인">nvm list 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>nvm list
</pre></td></tr></tbody></table></code></pre></div></div>

<p>우선 nvm list 명령어를 입력하여 현재 default 노드 버전이 무엇인지 확인합니다.</p>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/c9161fa3-eac9-4f3f-8360-044d20ea566a" alt="image" /></p>

<p>현재 저의 default 노드 버전은 v14.15.5로 되어있습니다. v18.17.0 으로 변경해보도록 하겠습니다.</p>

<h3 id="default-버전-변경">default 버전 변경</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>nvm <span class="nb">alias </span>default 18.17.0
</pre></td></tr></tbody></table></code></pre></div></div>

<p>default 버전을 변경하고자 하는 경우에는 <code class="language-plaintext highlighter-rouge">alias default</code> 명령어를 입력하면 됩니다.</p>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/0fb73df2-6cd4-4124-84b5-c89ae2c1673e" alt="image" /></p>

<p>위처럼 정상적으로 default 버전이 변경된 것을 확인하실 수 있습니다.<br />
앞으로 터미널을 재시작하더라도 버전이 변경되지 않습니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Setting" /><category term="NVM" /><category term="default" /><category term="nvm default" /><category term="node.js" /><category term="node" /><summary type="html"><![CDATA[NVM default node version setting]]></summary></entry><entry><title type="html">MySQL/MariaDB WITH RECURSIVE 재귀 쿼리</title><link href="http://localhost:4000/mariadb/post83/" rel="alternate" type="text/html" title="MySQL/MariaDB WITH RECURSIVE 재귀 쿼리" /><published>2023-10-29T00:00:00+09:00</published><updated>2023-10-29T00:00:00+09:00</updated><id>http://localhost:4000/mariadb/post83</id><content type="html" xml:base="http://localhost:4000/mariadb/post83/"><![CDATA[<p>오늘은 프로그래머스 문제를 풀다가 처음 알게된 문법이 있어서 공유해보고자 합니다. 바로 <code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 라는 재귀 쿼리입니다.</p>

<h3 id="with-recursive">WITH RECURSIVE</h3>

<p><code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 의 기본 구조는 아래와 같습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="err">테이블명</span> <span class="k">AS</span><span class="p">(</span>
  <span class="k">SELECT</span> <span class="err">초기값</span> <span class="k">AS</span> <span class="err">컬럼별명</span><span class="mi">1</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="k">SELECT</span> <span class="err">컬럼별명</span><span class="mi">1</span> <span class="err">계산식</span> <span class="k">FROM</span> <span class="err">테이블명</span> <span class="k">WHERE</span> <span class="err">제어문</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 는 아래와 같이 WITH와 RECURSIVE로 나눌 수 있습니다.</p>

<h3 id="with">WITH</h3>

<ul>
  <li><strong>CTE</strong>(common table expression)을 생성하는 문법</li>
  <li><strong>CTE</strong>란 해당 SQL문 내에서만 존재하는, 즉 메모리 상에 가상의 테이블을 저장할 때 사용된다.</li>
</ul>

<h3 id="recursive">RECURSIVE</h3>

<ul>
  <li>서브쿼리에서 스스로를 참조하는 <strong>CTE</strong></li>
  <li>가상의 테이블을 생성하면서 자신의 값을 참조하여 결정할 때 사용</li>
</ul>

<h3 id="예시">예시</h3>

<p>1부터 5까지 출력하는 예시입니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="n">d</span> 
<span class="k">AS</span> <span class="p">(</span>
    <span class="k">select</span> <span class="mi">1</span> <span class="k">as</span> <span class="n">n</span>
    <span class="k">union</span> <span class="k">all</span>
    <span class="k">select</span>
        <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">from</span> <span class="n">d</span>
    <span class="k">where</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="p">)</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">d</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="출력-결과">출력 결과</h4>

<p><img src="https://github.com/ilimes/ilimes.github.io/assets/95404736/709c02cc-9718-4d98-a498-6892f8949dc0" alt="image" /></p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="MariaDB" /><category term="데이터베이스" /><category term="DB" /><category term="MariaDB" /><category term="WITH RECURSIVE" /><summary type="html"><![CDATA[MySQL/MariaDB WITH RECURSIVE]]></summary></entry><entry><title type="html">React Native - Sticky Header (헤더 고정)</title><link href="http://localhost:4000/reactnative/post82/" rel="alternate" type="text/html" title="React Native - Sticky Header (헤더 고정)" /><published>2023-10-04T00:00:00+09:00</published><updated>2023-10-04T00:00:00+09:00</updated><id>http://localhost:4000/reactnative/post82</id><content type="html" xml:base="http://localhost:4000/reactnative/post82/"><![CDATA[<h3 id="sticky-header-사용법">Sticky Header 사용법</h3>

<p>앱을 만들다보면 스크롤을 내릴때 헤더를 고정하는 Sticky Header를 구현하고 싶을 때가 있는데요. React Native ScrollView에서는 간단히 구현할 수 있습니다.</p>

<p>아래와 같이 스크롤 뷰 속성에 <code class="language-plaintext highlighter-rouge">stickyHeaderIndices</code> 를 추가하면 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="p">&lt;</span><span class="nc">ScrollView</span> 
    <span class="na">stickyHeaderIndices</span><span class="p">=</span><span class="si">{</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span> <span class="c1">// 숫자: sticky 속성을 사용할 컴포넌트의 위치</span>
<span class="p">&gt;</span> 
   ...
<span class="p">&lt;/</span><span class="nc">ScrollView</span><span class="p">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>예를 들어 1번째 컴포넌트를 고정하고 싶다면 위와 같이 배열 안에 숫자를 <code class="language-plaintext highlighter-rouge">0</code>으로 설정해주면 됩니다.<br />
만약 <code class="language-plaintext highlighter-rouge">1</code>로 하면 2번째 컴포넌트가 고정됩니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="ReactNative" /><category term="리액트네이티브" /><category term="React" /><category term="RN" /><category term="Sticky" /><category term="stickyHeaderIndices" /><category term="scrollview" /><summary type="html"><![CDATA[리액트 네이티브 Sticky]]></summary></entry><entry><title type="html">Git - fatal: Unable to create ‘~~/.git/index.lock’: File exists. 에러 해결</title><link href="http://localhost:4000/git/post81/" rel="alternate" type="text/html" title="Git - fatal: Unable to create ‘~~/.git/index.lock’: File exists. 에러 해결" /><published>2023-10-04T00:00:00+09:00</published><updated>2023-10-04T00:00:00+09:00</updated><id>http://localhost:4000/git/post81</id><content type="html" xml:base="http://localhost:4000/git/post81/"><![CDATA[<h3 id="문제-상황">문제 상황</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>git add <span class="nb">.</span>
fatal: Unable to create <span class="s1">'디렉토리/.git/index.lock'</span>: File exists.

Another git process seems to be running <span class="k">in </span>this repository, e.g.
an editor opened by <span class="s1">'git commit'</span><span class="nb">.</span> Please make sure all processes
are terminated <span class="k">then </span>try again. If it still fails, a git process
may have crashed <span class="k">in </span>this repository earlier:
remove the file manually to <span class="k">continue</span><span class="nb">.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>git add .로 파일을 올리고자 할 때 갑자기 위와 같은 에러가 나는 경우가 있습니다.
이유는 <code class="language-plaintext highlighter-rouge">.git 디렉토리에 index.lock 파일이 존재하기 때문</code> 입니다.</p>

<h3 id="해결-방법">해결 방법</h3>

<p>해결 방법은 매우 간단합니다.</p>

<p>특정 Git 프로세스가 동작중일 때 다른 Git 프로세스가 실행되는 것을 막기 위해서 index.lock 이라는 파일이 생기는 것인데 의도해서 생성한 것이 아니라면 삭제해주면 됩니다. 폴더에서 직접 index.lock 파일을 삭제하거나, 아래 명령어를 입력하여 해결할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-f</span> .git/index.lock
</pre></td></tr></tbody></table></code></pre></div></div>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Git" /><category term="github" /><category term="Git" /><category term="깃" /><category term="에러해결" /><category term="fatal" /><summary type="html"><![CDATA[Git 에러 해결 방법]]></summary></entry><entry><title type="html">웹 브라우저 렌더링 종류와 차이점</title><link href="http://localhost:4000/web/post80/" rel="alternate" type="text/html" title="웹 브라우저 렌더링 종류와 차이점" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/web/post80</id><content type="html" xml:base="http://localhost:4000/web/post80/"><![CDATA[<p>렌더링이란 간단히 말하면 HTML, CSS, javaScript 등 개발자가 작성한 문서가 화면에 표시되는 것이라고 할 수 있는데요. 오늘은 웹 브라우저 렌더링의 종류에 대해서 알아보고, 각각 어떠한 장단점이 있는지 정리해보도록 하겠습니다 😊</p>

<h3 id="렌더링의-종류">렌더링의 종류</h3>

<p>렌더링의 종류는 크게 4가지로 구분할 수 있습니다.</p>

<hr />

<h4 id="서버-사이드-렌더링-ssr">서버 사이드 렌더링 (SSR)</h4>

<p>서버 사이드 렌더링이란 말 그대로 클라이언트가 요청하였을 때 <strong>서버측에서 렌더링</strong>을 해서 보내주는 것을 말합니다.</p>

<h5 id="장점">장점</h5>

<ul>
  <li>초기 로딩 속도가 빠르다.
    <ul>
      <li>해당 첫 페이지에 해당하는 문서만 브라우저에 전달하여 렌더링 하기 때문</li>
    </ul>
  </li>
  <li>자바스크립트 설정이 필요하지 않다.</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.
    <ul>
      <li>SEO란 웹을 크롤링하며 페이지에 컨텐츠 색인을 생성하는 과정</li>
    </ul>
  </li>
</ul>

<h5 id="단점">단점</h5>

<ul>
  <li>초기 로딩속도가 빠른만큼 TTV(Time To View)와 TTI(Time to Interact)간 시간 간격이 존재
    <ul>
      <li>TTV는 사용자가 웹사이트를 보는 것을 말하고, TTI는 클릭 이벤트와 같은 인터랙션이 가능한 상태</li>
    </ul>
  </li>
  <li>초기 로딩 이후에는 페이지 이동 속도가 다소 느릴 수 있다.
    <ul>
      <li>페이지 이동시마다 클라이언트가 서버에게 필요한 데이터를 요청하고, 서버가 응답해주는 방식이기 때문</li>
    </ul>
  </li>
  <li>매번 페이지가 새로고침 되어 사용자 경험이 떨어질 수 있다.</li>
</ul>

<hr />

<h4 id="클라이언트-사이드-렌더링-csr">클라이언트 사이드 렌더링 (CSR)</h4>

<p>클라이언트 사이드 렌더링은 서버 사이드 렌더링과 반대라고 할 수 있는데, 프로그래밍된 스크립트가 서버가 아닌 <strong>클라이언트(브라우저)</strong>에서 처리되는 것을 말합니다.</p>

<h5 id="장점-1">장점</h5>

<ul>
  <li>클라이언트에서 많은 것들이 이루어지기 때문에 초기 로딩이 느리지만, 로딩이 완료되고 나면 빠른 동작이 가능</li>
  <li>서버에 부하가 적음</li>
</ul>

<h5 id="단점-1">단점</h5>

<ul>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)에 대한 보완 작업 필요
    <ul>
      <li>검색 엔진 크롤러가 웹사이트에 대한 데이터를 제대로 수집하지 못하는 경우가 발생할 수 있습니다. SEO를 위해서 sitemap 문서 작성과 같은 과정이 필요할 수 있습니다.</li>
    </ul>
  </li>
  <li>보안에 취약</li>
</ul>

<hr />

<h4 id="정적-사이트-생성-ssg">정적 사이트 생성 (SSG)</h4>

<p>SSG란 Static Site Generation의 약자로 <strong>정적인 페이지</strong>를 생성하는 것을 말합니다.</p>

<h5 id="장점-2">장점</h5>

<ul>
  <li>초기 로딩이 빠르다</li>
  <li>자바스크립트 설정이 필요하지 않다.</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.</li>
  <li>보안이 좋다</li>
</ul>

<h5 id="단점-2">단점</h5>

<ul>
  <li>데이터가 정적이다
    <ul>
      <li>블로그와 같이 데이터가 잘 바뀌지 않는 사이트 같은 경우 사용하기 적합하지만, 변화가 자주 이뤄져야 하는 경우에는 적합하지 않음</li>
    </ul>
  </li>
  <li>사용자별로 달라지는 데이터 제공 어려움</li>
</ul>

<hr />

<h4 id="증분-정적-재생-isr">증분 정적 재생 (ISR)</h4>

<p>ISR이란 Incremental Static Regeneration의 약자로 SSG를 보완하기 위해 정적인 사이트를 서버 측에서 주기적으로 렌더링 하는 것을 말합니다.<br />
전체적인 원리는 SSG와 동일하고, 설정한 주기만큼 페이지를 계속 다시 만들어줍니다.</p>

<h5 id="장점-3">장점</h5>

<ul>
  <li>초기 로딩이 빠르다</li>
  <li>검색 엔진 최적화(SEO - Search Engine Optimization)가 좋다.</li>
  <li>보안이 좋다</li>
  <li>주기적으로 데이터가 업데이트 된다</li>
</ul>

<h5 id="단점-3">단점</h5>

<ul>
  <li>주기적인 변경이 가능하지만 실시간 데이터가 아니다</li>
  <li>사용자별로 달라지는 데이터 제공 어려움</li>
</ul>

<hr />

<p>오늘 이렇게 4가지 웹 브라우저 렌더링 방식에 대해서 알아보았는데요. 각각의 특징이 있기 때문에 상황에 맞게 잘 적용해야겠다는 생각이 들었습니다.</p>

<p>참고로 <code class="language-plaintext highlighter-rouge">Next.js</code> 같은 경우는 성능 좋은 강력한 웹앱을 만들기 위해서 두 개 이상의 렌더링 방법을 사용하는 하이브리드 방식을 지원하고 있습니다 :)</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Web" /><category term="렌더링" /><category term="SSR" /><category term="CSR" /><category term="SSG" /><category term="ISR" /><summary type="html"><![CDATA[SSR, CSR, SSG, ISR에 대해서 알아보기]]></summary></entry><entry><title type="html">[Windows] 인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기</title><link href="http://localhost:4000/issue/post79/" rel="alternate" type="text/html" title="[Windows] 인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기" /><published>2023-04-29T00:00:00+09:00</published><updated>2023-04-29T00:00:00+09:00</updated><id>http://localhost:4000/issue/post79</id><content type="html" xml:base="http://localhost:4000/issue/post79/"><![CDATA[<p>최근 스프링부트 개발을 인텔리제이로 하고있는데, 맥과 윈도우를 번갈아가면서 사용하고 있습니다.<br />
맥에서는 별도로 무언가 설정하지 않아도 문제없이 한글로된 콘솔이 잘 찍혔는데, 윈도우에서는 인텔리제이에 별도로 설정을 해놓지 않으면 한글이 깨져서 나오더라고요.<br />
<br />
그래서 오늘은 저처럼 인텔리제이 한글 콘솔 문제를 겪고, 해결방법을 찾고 계신 분들을 위해서 간단하게 해결 방법을 소개해드리도록 하겠습니다 :)</p>

<h3 id="해결방법">해결방법</h3>

<p><img src="https://user-images.githubusercontent.com/95404736/235306346-ad3fb520-7f71-4d8b-bf81-dbbd97cd5edd.png" alt="image" width="500" /></p>

<p>인텔리제이 상단 메뉴에서 ‘Help - Edit Custom VM Options…‘를 찾아서 클릭합니다.</p>

<p><img width="600" alt="image" src="https://user-images.githubusercontent.com/95404736/235306442-3bf3857f-e4a3-4624-af58-7ee167f4c001.png" /></p>

<p>그럼 위 이미지에서 보이는 것처럼 파일이 하나 열리게 됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>-Dfile.encoding=UTF-8
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 코드를 이미지 두번째 줄처럼 붙여 넣어주세요.<br />
그리고 인텔리제이를 재시작하면 한글 깨짐 문제가 해결됩니다.</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="Issue" /><category term="인텔리제이" /><category term="IntelliJ" /><category term="한글" /><category term="한글깨짐" /><summary type="html"><![CDATA[인텔리제이(IntelliJ) 콘솔 한글 깨짐 수정하기]]></summary></entry><entry><title type="html">CH12. 제품 소프트웨어 패키징</title><link href="http://localhost:4000/infoprocessing/post78/" rel="alternate" type="text/html" title="CH12. 제품 소프트웨어 패키징" /><published>2023-03-25T00:00:00+09:00</published><updated>2023-03-25T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post78</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post78/"><![CDATA[<h3 id="제품-소프트웨어-패키징-하기">제품 소프트웨어 패키징 하기</h3>

<h4 id="제품-소프트웨어-패키징product-software-packaging">제품 소프트웨어 패키징(Product Software Packaging)</h4>

<p>개발이 완료된 제품 소프트웨어를 고객에게 전달하기 위한 형태로 포장하는 과정</p>

<ul>
  <li>사용자 중심의 모듈 패키징 프로세스: 기능 식별 → 모듈화 → 빌드 진행 → 사용자 환경 분석 → 패키징 적용 시험 → 패키징 변경 개선</li>
</ul>

<h4 id="릴리즈-노트release-note">릴리즈 노트(Release Note)</h4>

<p>고객에게 개발 과정에서 정리된 제품의 릴리즈 정보를 제공하는 문서</p>

<ul>
  <li>릴리즈 노트 작성 프로세스: 모듈 식별 → 릴리즈 정보 확인 → 릴리즈 노트 개요 작성 → 영향도 체크 → 정식 릴리즈 노트 작성 → 추가 개선 항목 식별</li>
</ul>

<h4 id="제품-소프트웨어-패키징-도구">제품 소프트웨어 패키징 도구</h4>

<p>배포를 위한 패키징 시에 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능 제공하며, 안전한 유통과 배포를 보장하는 도구</p>

<h4 id="패키징-도구-활용-시-고려-사항">패키징 도구 활용 시 고려 사항</h4>

<ul>
  <li>암호화/보안 고려: 내부 콘텐츠에 대한 암호화 및 보안 고려</li>
  <li>이기종 연동을 고려: 이기종 콘테츠 및 단말기 간 DRM 연동 고려</li>
  <li>사용자 편의성 고려: 사용자 입장에서 문제를 고려하여 최대한 효율적으로 적용</li>
  <li>적합한 암호화 알고리즘 적용: 제품 소프트웨어 종류에 맞는 알고리즘을 선택하여 배포 시 범용성에 지장이 없도록 고려</li>
</ul>

<h4 id="저작권copyright">저작권(Copyright)</h4>

<p>창작물인 저작물에 대한 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한</p>

<h4 id="디지털-저작권-관리drm-digital-right-management">디지털 저작권 관리(DRM: Digital Right Management)</h4>

<p>저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠 관리 및 보호 기술</p>

<h4 id="디지털-저작권-관리drm-구성요소">디지털 저작권 관리(DRM) 구성요소</h4>

<ul>
  <li>콘텐츠 제공자(Content Provider): 콘텐츠를 제공하는 저작권자</li>
  <li>콘텐츠 소비자(Content Customer): 콘텐츠를 구매하여 사용하는 주체</li>
  <li>콘텐츠 분배자(Contents Distributor): 암호화된 콘텐츠를 유통하는 곳이나 사람</li>
  <li>클리어링 하우스(Clearing House): 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳</li>
  <li>DRM 콘텐츠(DRM Content): 서비스하고자 하는 암호화된 콘텐츠, 콘텐츠와 관련된 메타데이터, 콘텐츠 사용정보를 패키징하여 구성된 콘텐츠</li>
  <li>패키저(Packager): 콘텐츠를 메타데이터와 함꼐 배포 가능한 단위로 묶은 도구</li>
  <li>DRM 컨트롤러(DRM Controller): 배포된 디지털 콘텐츠의 이용 권한을 통제</li>
  <li>보안 컨테이너(Security Contatiner): 원본 콘텐츠를 안전하게 유통하기 위한 전자적 보안장치</li>
</ul>

<h4 id="패키징-도구-구성-세부-기술">패키징 도구 구성 세부 기술</h4>

<ul>
  <li>암호화: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술</li>
  <li>키 관리: 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술</li>
  <li>암호화 파일 생성: 콘텐츠 암호화된 콘텐츠로 생성하기 위한 기술</li>
  <li>식별 기술: 콘텐츠에 대한 식별 체계 표현 기술</li>
  <li>저작권 표현: 라이선스의 내용 표현 기술</li>
  <li>정책 관리: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술</li>
  <li>크랙방지: 크랙에 의한 콘텐츠 사용 방지 기술</li>
  <li>인증: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술</li>
</ul>

<h3 id="제품-소프트웨어-매뉴얼-작성-및-버전-등록">제품 소프트웨어 매뉴얼 작성 및 버전 등록</h3>

<h4 id="제품-소프트웨어-매뉴얼">제품 소프트웨어 매뉴얼</h4>

<p>사용자 측면에서 패키징 이후 설치, 제품 소프트웨어를 사용하는 데 필요한 주요 내용을 기록한 문서</p>

<h4 id="제품-소프트웨어-사용자-매뉴얼">제품 소프트웨어 사용자 매뉴얼</h4>

<p>사용자가 소프트웨어 사용에 필요한 내용을 포함한 문서</p>

<h4 id="제품-소프트웨어-배포본">제품 소프트웨어 배포본</h4>

<p>사용자가 사용하기 편하도록 배포 정보를 포함하여 개발된 컴포넌트 또는 패키지가 제품화된 형태</p>

<h4 id="백업-유형">백업 유형</h4>

<ul>
  <li>전체 백업(Full Backup): 백업받고자 하는 데이터 전체에 대한 백업을 하는 방식</li>
  <li>차등 백업(Differential Backup): 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식</li>
  <li>증분 백업(Incremental Backup): 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업하는 방식</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="제품" /><category term="제품소프트웨어패키징" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 제품 소프트웨어 패키징]]></summary></entry><entry><title type="html">CH11. 응용 SW 기초 기술 활용</title><link href="http://localhost:4000/infoprocessing/post77/" rel="alternate" type="text/html" title="CH11. 응용 SW 기초 기술 활용" /><published>2023-03-19T00:00:00+09:00</published><updated>2023-03-19T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post77</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post77/"><![CDATA[<h3 id="운영체제의-특징">운영체제의 특징</h3>

<h4 id="운영체제os-operating-system">운영체제(OS: Operating System)</h4>

<p>사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어</p>

<h5 id="운영체제-종류">운영체제 종류</h5>

<p>윈도우즈(Windows), 유닉스(Unix), 리눅스(Linux), 맥(Mac), 안드로이드(Android)</p>

<h4 id="메모리-관리-기법">메모리 관리 기법</h4>

<ul>
  <li>반입 기법: 메모리 적재 시기 결정(When)</li>
  <li>배치 기법: 메모리 적재 위치 결정(Where)</li>
  <li>할당 기법: 메모리 적재 방법 결정(How)</li>
  <li>교체 기법: 메모리 교체 대상 결정(Who)</li>
</ul>

<h4 id="메모리-배치-기법">메모리 배치 기법</h4>

<ul>
  <li>최초 적합(First-fit): 프로세스가 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식</li>
  <li>최적 적합(Best fit): 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재하는 방식</li>
  <li>최악 접합(Worst-fit): 프로세스의 가용 공간들 중에서 가장 큰 공간에 할당하는 방식</li>
</ul>

<h4 id="프로세스-상태">프로세스 상태</h4>

<ul>
  <li>생성(Create) 상태: 사용자에 의해 프로세스가 생성된 상태</li>
  <li>준비(Ready) 상태: CPU를 할당받을 수 있는 상태</li>
  <li>실행(Running) 상태: 프로세스가 CPU를 할당받아 동작 중인 상태</li>
  <li>대기(Waiting) 상태: 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태</li>
  <li>완료(Complete) 상태: 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태</li>
</ul>

<h4 id="프로세스-상태-전이">프로세스 상태 전이</h4>

<p><img width="618" alt="image" src="https://user-images.githubusercontent.com/95404736/226170556-97d36ab6-f195-4c78-a98f-20e9b023729f.png" /></p>

<h4 id="프로세스-스케줄링의-유형">프로세스 스케줄링의 유형</h4>

<ul>
  <li>선점형 스케줄링: 우선순위가 높은 프로세스가 CPU를 점유하는 스케줄링
    <ul>
      <li>라운드 로빈(Round Robbin): 프로세스는 같은 크기의 CPU 시간 할당</li>
      <li>SRT(Shortest Remaining Time First): 가장 짧은 시간이 소요되는 프로세스를 먼저 수행</li>
      <li>다단계 큐(Multi Level Queue): 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점</li>
      <li>다단계 피드백 큐(Multi Level Feedback Queue): 큐마다 서로 다른 CPU시간 할당량을 부여, FIFO+라운드 로빈 스케줄링 기법 혼합</li>
    </ul>
  </li>
  <li>비선점형 스케줄링: 한 프로세스가 CPU를 할당 받으면 작업 종료 전까지 다른 프로세스는 CPU점유 불가능한 스케줄링
    <ul>
      <li>우선순위(Priority): 프로세스별 우선순위에 따라 CPU 할당</li>
      <li>기한부(Deadline): 작업들이 명시된 기한 내에 완료되도록 계획</li>
      <li>FCFS(First Come First Service): 프로세스가 대기 큐에 도착한 순서에 따라 CPU할당=FIFO</li>
      <li>SJF(Shortest Job First): 가장 짧은 작업부터 수행, 평균 대시 시간 최소화. 기아현상 발생</li>
      <li>HRN(Highest Response Ratio Next): 대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 기법</li>
    </ul>
  </li>
</ul>

<h4 id="가상화virtualization">가상화(Virtualization)</h4>

<p>물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술</p>

<h4 id="클라우드-컴퓨팅cloud-computing">클라우드 컴퓨팅(Cloud Computing)</h4>

<p>인터넷을 통해 가상화된 컴퓨터 시스템 리소스 제공</p>

<h4 id="클라우드-컴퓨팅-유형">클라우드 컴퓨팅 유형</h4>

<ul>
  <li>인프라형 서비스(IaaS: Infrastructure as a Service): 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스</li>
  <li>플랫폼형 서비스(Paas: Platform as a Service): 애플리케이션 개발, 실행, 관리할 수 있게하는 플랫폼을 제공하는 서비스</li>
  <li>소프트웨어형 서비스(SaaS: Software as a Service): 클라이언트 통해 접속하여 소프트웨어 서비스 형태로 이용하는 서비스</li>
</ul>

<h3 id="네트워크-계층-구조-파악">네트워크 계층 구조 파악</h3>

<h4 id="네트워크network">네트워크(Network)</h4>

<p>원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라</p>

<ul>
  <li>광대역 네트워크(WAN): LAN에 비해 전송거리가 넓음</li>
  <li>근거리 네트워크(LAN): 한 건물 또는 작은 지역 커버</li>
</ul>

<h4 id="osiopen-system-interconnection-7계층">OSI(Open System Interconnection) 7계층</h4>

<ul>
  <li>응용 계층(Application Layer): 사용자와 네트워크 간 응용서비스 연결, 데이터 생성</li>
  <li>표현 계층(Presentation Layer): 데이터 형식 설정, 부호교환, 암/복호화</li>
  <li>세션 계층(Session Layer): 송수신 간의 논리적인 연결</li>
  <li>전송 계층(Transport Layer): 송수신 프로세스 간의 연결</li>
  <li>네트워크 계층(Network Layer): 단말기 간 데이터 전송을 위한 최적화된 경로 제공</li>
  <li>데이터링크 계층(Data Link Layer): 인접 시스템 간 데이터 전송, 전송 오류 제어</li>
  <li>물리 계층(Physical Layer): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환</li>
</ul>

<h4 id="프로토콜protocol">프로토콜(Protocol)</h4>

<p>서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약</p>

<h4 id="프로토콜-기본-3요소">프로토콜 기본 3요소</h4>

<ul>
  <li>구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규적</li>
  <li>의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정</li>
  <li>타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정</li>
</ul>

<h4 id="네트워크-프로토콜network-protocol">네트워크 프로토콜(Network Protocol)</h4>

<p>컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계</p>

<h4 id="데이터-링크-계층-프로토콜">데이터 링크 계층 프로토콜</h4>

<ul>
  <li>HDLC(High-level Data Link Control): 점대점 방식이나 다중방식 통신에 사용되며, 동기식 비트 중심</li>
  <li>PPP(Point-to-Point Protocol): 네트워크 분야에서 두 통신 노드 간의 직접적인 연결</li>
  <li>프레임 릴레이(Frame Relay): 프로토콜 처리를 간략화하여 데이터 처리속도의 향상 및 전송 지연을 감소시킨 고속데이터 전송 기술</li>
  <li>ATM(Asynchronous Transport Mode): 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술</li>
</ul>

<h4 id="네트워크-계층-프로토콜">네트워크 계층 프로토콜</h4>

<ul>
  <li>IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용</li>
  <li>ARP(Adress Resolution Protocol): IP네트워크상에서 IP주소를 MAC주소(물리주소)로 변환하는 프로토콜</li>
  <li>RARP(Reverse Address Resolution Protocol): 서버로부터 IP 주소를 요청하기위해 사용하는 프로토콜</li>
  <li>ICMP(Internet Control Message Protocol): IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜</li>
  <li>IGMP(Internet Group Managemnet Protocol): 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜</li>
  <li>라우팅 프로토콜(Routing Protocol): 데이터 전송을 위해 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜</li>
</ul>

<h4 id="ipv4-internet-protocol-version-4">IPv4 (Internet Protocol version 4)</h4>

<p>인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층 프로토콜</p>

<ul>
  <li>8비트씩 4부분으로 나뉜 10진수</li>
  <li>0~255까지 3자리수 표현</li>
  <li>유니캐스트, 멀티캐스트, 브로드캐스트</li>
</ul>

<h4 id="ipv4-클래스-분류">IPv4 클래스 분류</h4>

<ul>
  <li>A클래스: 국가나 대형 통신망에 사용(1~127), 네트워크 사용자에게 부여가 가능한 IP</li>
  <li>B클래스: 중대형 통신망에 사용(128~191)</li>
  <li>C클래스: 소규모 통신망에 사용(192~223)</li>
  <li>D클래스: 멀티캐스트 용도로 예약된 주소(224~239)</li>
  <li>E클래스: 연구를 위해 예약된 주소(공용 사용 불가)</li>
</ul>

<h4 id="ipv6-internet-protocol-version-6-ipv4의-주소-부족-문제를-해결하기-위해-개발">IPv6 (Internet Protocol version 6): IPv4의 주소 부족 문제를 해결하기 위해 개발</h4>

<ul>
  <li>IPv4에 비해 자료 전송속도가 빠름</li>
  <li>128비트 주소체계</li>
  <li>16비트씩 8개 부분으로 나눈 16진수</li>
  <li>유니캐스트, 멀티캐스트, 애니캐스트</li>
</ul>

<h4 id="ipv4에서-ipv6으로-전환-방법-듀얼-스택-터널링-주소-변환-방식">IPv4에서 IPv6으로 전환 방법: 듀얼 스택, 터널링, 주소 변환 방식</h4>

<h4 id="라우팅-프로토콜">라우팅 프로토콜</h4>

<ul>
  <li>내부 라우팅 프로토콜(IGP)
    <ul>
      <li>RIP(Routing Information Protocol): AS(자율시스템)내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜</li>
      <li>OSPF(Oepn Shortest Path First): 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜</li>
    </ul>
  </li>
  <li>외부 라우팅 프로토콜(EGP)
    <ul>
      <li>BGP(Border Gateway Protocol): AS상호 간에 경로 정보를 교환하기 위한 라우팅 프로토콜</li>
    </ul>
  </li>
</ul>

<h4 id="tcptransmission-control-protocol">TCP(Transmission Control Protocol):</h4>

<ul>
  <li>TCP 특징: 신뢰성 보장, 연결 지향적 특징, 흐름 제어, 혼잡 제어</li>
</ul>

<h4 id="udpuser-datagram-protocol">UDP(User Datagram Protocol):</h4>

<ul>
  <li>UDP 특징: 비신뢰성, 순서화되지 않은 데이터그램 서비스 제공, 실시간 응용 및 멀티캐스트 가능, 단순 헤어</li>
</ul>

<h4 id="표현계층-프로토콜">표현계층 프로토콜</h4>

<ul>
  <li>JPEG: 이미지를 위해 만들어진 표준 규격</li>
  <li>MPEG: 멀티미디어(비디오, 오디오)를 위해 만들어진 표준 규격</li>
</ul>

<h4 id="응용계층-프로토콜">응용계층 프로토콜</h4>

<ul>
  <li>HTTP(Hyper Text Transfer Protocol): 텍스트 기반의 통신구약, 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜</li>
  <li>FTP(File Transfer Protocol): TCP/IP를 갖고 서버와 클라이언트 사이의 파일을 전송하기 위한 프로토콜</li>
  <li>SMTP(Simple Mail Transfer Protocol): 인터넷에서 TCP포트 25번을 사용하여 이메일을 보내기 위해 이용되는 프로토콜</li>
  <li>POP3(Post Office Protocol Version 3): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는 데 사용하는 프로토콜</li>
  <li>IMAP(Internet Messaging Access Protocol): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는 데 사용하는 프로토콜</li>
  <li>Telnet: 인터넷이나 로컬 영역에서 네트워크 연결에 사용되는 네트워크 프로토콜</li>
  <li>SSH(Secure Shell): 서로 연결되어 있는 컴퓨터 간 원격 명령 실행이나 쉘 서비스 등을 수행, Telent보다 강력한 보안 제공</li>
  <li>SNMP(Simple Network Managemnet Protocol): 라우터나 허브 등 네트워크 장치로부터 정보를 수집 및 관리</li>
</ul>

<h4 id="패킷-교환-방식packet-switching">패킷 교환 방식(Packet Switching)</h4>

<p>작은 블록의 패킷으로 데이터를 전송하여 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 통신 방식</p>

<ul>
  <li>활용: 이메일, 메시지</li>
</ul>

<h4 id="패킷-교환-방식-기술">패킷 교환 방식 기술</h4>

<ul>
  <li>X.25: 통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜</li>
  <li>프레임 릴레이: ISDN을 사용하기 위한 프로토콜로서 ITU-T에 의해 표준으로 작성</li>
  <li>ATM(Asynchronous Transfer Mode): 비동기 전송모드, 광대역 전송에 쓰이는 스위칭 기법</li>
</ul>

<h4 id="서킷-교환-방식circuit-switching">서킷 교환 방식(Circuit Switching)</h4>

<p>네트워크 리스소를 특정 사용층이 독접하도록 하는 통신 방식</p>

<ul>
  <li>활용: 영상, 비디오</li>
</ul>

<h4 id="애드-혹-네트워크ad-hoc-network">애드 혹 네트워크(Ad-hoc Network)</h4>

<p>노드들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크</p>

<h3 id="기본-개발환경-구축하기">기본 개발환경 구축하기</h3>

<h4 id="개발환경-인프라-구성-방식">개발환경 인프라 구성 방식</h4>

<ul>
  <li>온프레미스(On-Premise) 방식: 외부 인터넷망이 차단된 상태에서 인트라넷망만을 활용하여 개발환경을 구축하는 방식</li>
  <li>클라우드(Cloud) 방식: 클라우드 공습 서비스를 제공하는 회사들(아마존, 구글, MS 등)의 서비스를 임대하여 개발 환경을 구축하는 방식</li>
  <li>하이브리드(Hybrid) 방식: 온프레미스와 클라우드 방식을 혼용한 방식</li>
</ul>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="응용SW" /><category term="소프트웨어" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 응용 SW 기초 기술 활용]]></summary></entry><entry><title type="html">CH10. 애플리케이션 테스트 관리</title><link href="http://localhost:4000/infoprocessing/post76/" rel="alternate" type="text/html" title="CH10. 애플리케이션 테스트 관리" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/infoprocessing/post76</id><content type="html" xml:base="http://localhost:4000/infoprocessing/post76/"><![CDATA[<h3 id="애플리케이션-테스트-케이스-설계">애플리케이션 테스트 케이스 설계</h3>

<h4 id="애플리케이션-테스트">애플리케이션 테스트</h4>

<p>애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차</p>

<h4 id="애플리케이션-테스트-원리">애플리케이션 테스트 원리</h4>

<ul>
  <li>완벽한 테스팅은 불가능: 결함을 줄일 수는 있으나, 결함이 없다고 증명할 수 없음</li>
  <li>파레토 법칙(Pareto Principle): 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙</li>
  <li>살충제 패러독스(Pesticide Paradox): 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상</li>
  <li>정황 의존성: 소프트웨어 성격에 맞게 테스트 실시</li>
  <li>오류-부재의 궤변: 요구사항을 충족시키주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음</li>
</ul>

<h4 id="프로그램-실행-여부에-따른-분류">프로그램 실행 여부에 따른 분류</h4>

<ul>
  <li>정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트 (리뷰, 정적 분석)</li>
  <li>동적 테스트: 소프트웨어 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트 (화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트)</li>
</ul>

<h4 id="화이트박스-테스트white-box-test">화이트박스 테스트(White-Box Test)</h4>

<p>원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법 (구조 검사)</p>

<h5 id="화이트박스-테스트-유형">화이트박스 테스트 유형</h5>

<ul>
  <li>구문(문장) 커버리지 : 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지</li>
  <li>결정(선택, 분기) 커버리지 : 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지</li>
  <li>조건/결정 커버리지 : 전체 조건식 &amp; 개별 조건식 모두 참 한번, 거짓 한 번 결과가 되도록 수행하는 커버리지</li>
  <li>변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 하는 커버리지</li>
  <li>다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지</li>
  <li>기본 경로 커버리지 : 수행 가능한 모든 경로를 테스트 하는 기법</li>
  <li>제어 흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법</li>
  <li>데이터 흐름 테스트 : 제어 흐름 그래프에 사용현황 추가한 테스트 기법</li>
</ul>

<h4 id="블랙박스-테스트black-box-test">블랙박스 테스트(Black-Box Test)</h4>

<p>사용자의 요구사항 명세를 보면서 수행하는 테스트 (기능 검사)</p>

<h5 id="블랙박스-테스트-유형">블랙박스 테스트 유형</h5>

<ul>
  <li>동등 분할 테스트 : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법</li>
  <li>경곗값 분석 테스트 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법</li>
  <li>결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합해 테스트</li>
  <li>상태 전이 테스트 : 이벤트에 의해 어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트</li>
  <li>유스케이스 테스트 : 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트</li>
  <li>분류 트리 테스트 : SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계하여 테스트</li>
  <li>페어와이즈 테스트 : 테스트 데이터 값들 간에 최소한 한 번씩을 조합하는 방식</li>
  <li>원인-결과 그래프 테스트 : 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 케이스를 선정하여 테스트</li>
  <li>비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어 동일한 데이터가 나오는지 비교하는 테스트</li>
</ul>

<h4 id="테스트-시각에-따른-분류">테스트 시각에 따른 분류</h4>

<ul>
  <li>검증(Verification): 소프트웨어 개발 과정을 테스트, 개발자 또는 시험자의 시각</li>
  <li>확인(Validation): 소프트웨어 결과를 테스트, 사용자 시각</li>
</ul>

<h4 id="테스트-목적에-따른-분류">테스트 목적에 따른 분류</h4>

<ul>
  <li>회복 테스트(Recovery Testing): 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트 하는 기법</li>
  <li>안전 테스트(Security Testing): 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법</li>
  <li>성능 테스트(Perfomance Testing): 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법</li>
  <li>구조 테스트(Structure Testing): 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법</li>
  <li>회귀 테스트(Refression Testing): 시스템의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트</li>
  <li>병행 테스트(Parallel Testing): 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법</li>
</ul>

<h4 id="성능-테스트의-상세-유형">성능 테스트의 상세 유형</h4>

<ul>
  <li>부하 테스트(Load Testing): 시스템에 부가를 계속 증가시켜 시스템의 임계점을 찾는 테스트</li>
  <li>강도 테스트(Stress Testing): 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리 테스트</li>
  <li>스파이크 테스트(Spike Testing): 짧은 시간에 사용자가 몰릴 때 시스템의 반응 층정 테스트</li>
  <li>내구성 테스트(Endurance Testing): 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트</li>
</ul>

<h4 id="테스트-종류에-따른-분류">테스트 종류에 따른 분류</h4>

<ul>
  <li>명세 기반 테스트(블랙박스 테스트): 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트 하는 기법</li>
  <li>구조 기반 테스트(화이트박스 테스트): 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법</li>
  <li>경험 기반 테스트(블랙박스 테스트): 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트</li>
</ul>

<h4 id="테스트-케이스test-case">테스트 케이스(Test Case)</h4>

<p>사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 테스트 항목에 대한 명세서</p>

<h4 id="테스트-오라클test-oracle">테스트 오라클(Test Oracle)</h4>

<p>테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법</p>

<h5 id="테스트-오라클-종류">테스트 오라클 종류</h5>

<ul>
  <li>참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 제공하는 오라클</li>
  <li>샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클</li>
  <li>휴리스틱(Heuristic) 오라클: 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정(휴리스틱)으로 처리하는 오라클</li>
  <li>일관성 검사(Consistent) 오라클: 애플리케이션 변경이 있을 때, 수행 전과후의 결괏값이 동일한지 확인하는 오라클</li>
</ul>

<h4 id="테스트-레벨test-level">테스트 레벨(Test Level)</h4>

<p>함께 편성되고 관리되는 테스트 활동의 그룹</p>

<h5 id="테스트-레벨-종류">테스트 레벨 종류</h5>

<ul>
  <li>단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트 하는 단계</li>
  <li>통합 테스트: 단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</li>
  <li>시스템 테스트: 개발된 소프트웨어가 정상적으로 수행되는지 검증하는 테스트</li>
  <li>인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트</li>
</ul>

<h4 id="소프트웨어-개발단계">소프트웨어 개발단계</h4>

<p>요구사항 → 분석 → 설계 → 구현</p>

<h4 id="테스트-단계">테스트 단계</h4>

<p>단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트</p>

<h4 id="인수-테스트">인수 테스트</h4>

<ul>
  <li>사용자 인수 테스트: 사용자가 시스템 사용의 적절성 여부를 확인</li>
  <li>운영상의 인수 테스트: 시스템 관리자가 시템 인수 시 수행하는 테스트 기법</li>
  <li>계약 인수 테스트: 계약상의 인수/검수 조건을 준수하는지 여부를 확인</li>
  <li>규정 인수 테스트: 소프트웨어가 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인</li>
  <li>알파 테스트: 개발자의 장소에서 사용자가 개발자와 함께 행하는 테스트 기법</li>
  <li>베타 테스트: 실제 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 테스트</li>
</ul>

<h4 id="테스트-시나리오test-scenario">테스트 시나리오(Test Scenario)</h4>

<p>테스트 수행을 위한 여러 테스트 케이스의 집합, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서</p>

<h3 id="애플리케이션-통합-테스트">애플리케이션 통합 테스트</h3>

<h4 id="단위-테스트unit-test">단위 테스트(Unit Test)</h4>

<p>개별적인 모듈(또는 컴포넌트)을 테스트</p>

<h4 id="목mock-객체-생성-프레임워크">목(Mock) 객체 생성 프레임워크</h4>

<p>객체 지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존하는데 이런 경우 메서드를 고립화하여 테스트하는 것이 불가능하므로 독집적인 컴포넌트 테스트를 위해서는 스텁의 객체 지향 버전인 목 객체가 필요하다</p>

<h5 id="목-객체-유형-더미-객체-테스트-스텁-테스트-드라이버-테스트-스파이-가짜-객체">목 객체 유형: 더미 객체, 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체</h5>

<h4 id="통합-테스트intergration-test">통합 테스트(Intergration Test)</h4>

<p>단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</p>

<h5 id="통합-테스트-수행-방법-간-비교">통합 테스트 수행 방법 간 비교</h5>

<ul>
  <li>빅뱅 테스트: 모든 모듈을 동시에 통합 후 테스트 수행
    <ul>
      <li>드라이브/스텁: 드라이버/스텁 없이 실제 모듈로 테스트</li>
    </ul>
  </li>
  <li>상향식 테스트: 최하위 모듈부터 점진적으로 상위 모듈과 함께 테스트
    <ul>
      <li>드라이브/스텁: 테스트 드라이버 필요</li>
    </ul>
  </li>
  <li>하향식 테스트: 최상위 모듈부터 하위 모듈들을 통합하면서 테스트
    <ul>
      <li>드라이브/스텁: 테스트 스텁 필요</li>
    </ul>
  </li>
  <li>샌드위치 테스트: 상위는 하향식+하위는 상향식 테스
    <ul>
      <li>드라이브/스텁: 테스트스텁, 드라이버 필요</li>
    </ul>
  </li>
</ul>

<h4 id="테스트-자동화-도구">테스트 자동화 도구</h4>

<p>반복적인 테스트 작업을 스크립트 형태로 구현함으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 있는 방법</p>

<h4 id="테스트-자동화-도구-유형">테스트 자동화 도구 유형</h4>

<ul>
  <li>정적 분석 도구(Static Analysis Tools): 만들어진 애플리케이션을 실행하지 않고 분석하는 도구</li>
  <li>테스트 실행 도구(Test Execution Tools): 테스트를 위해 작성된 스크립트를 실행하고, 스크립트 언어를 사용하여 테스트를 실행하는 도구</li>
  <li>성능 테스트 도구(Perfomance Test Tools): 가상의 사용자를 생성하고 테스트를 수행하여 목표를 달성했는지 확인 하는 도구</li>
  <li>테스트 통제 도구(Test Control Tools): 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구</li>
  <li>테스트 하네스 도구(Test Harness Tools): 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구</li>
</ul>

<h4 id="테스트-하네스-구성요소-테스트-드라이버-테스트-스텁-테스트-슈트-테스트-케이스-테스트-시나리오-테스트-스크립트-목-오브젝트">테스트 하네스 구성요소: 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 시나리오, 테스트 스크립트, 목 오브젝트</h4>

<h4 id="소프트웨어-결함-개발자-오류로-인해-만들어지는-문서-또는-코딩상의-결점으로-개발자가-설계한-것과-다르게-동작하거나-다른-결과가-발생하는-현상">소프트웨어 결함: 개발자 오류로 인해 만들어지는 문서 또는 코딩상의 결점으로 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 현상</h4>

<h4 id="테스트-결함-관리-단계별-테스트-수행-후-발생한-결함의-재발-방지와-유사-결함-발견-시-처리-시간-단축을-위해-결함을-추적하고-관리하는-활동">테스트 결함 관리: 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동</h4>

<h4 id="결함-분석-방법">결함 분석 방법</h4>

<ul>
  <li>구체화: 결함의 원인을 찾기 위해 결함을 발생기킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악하는 방법</li>
  <li>고립화: 입력값, 테스트 절차, 테스트 환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법</li>
  <li>일반화: 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법</li>
</ul>

<h4 id="테스트-커버리지test-coverage">테스트 커버리지(Test Coverage)</h4>

<p>주어진 테스트 케이스에 의해 수행되는 소프트웨어 테스트 범위를 측정하는 테스트 품질 측정 기준</p>

<h4 id="테스트-커버리지-유형">테스트 커버리지 유형</h4>

<ul>
  <li>기능 기반 커버리지: 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법</li>
  <li>라인 커버리지: 전체 소스 코드의 라인수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인수를 측정하는 방법</li>
  <li>코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트되었는지를 측정하는 방법</li>
</ul>

<h4 id="결함-심각도별-분류">결함 심각도별 분류</h4>

<p>단순 결함(미관상 안좋음) → 경미한 결함(표준위반) → 보통 결함(사소한 기능 오작동) → 주요 결함(기능 장애) → 치명적 결함(데이터손실)</p>

<h4 id="결함-우선순위">결함 우선순위</h4>

<p>낮음(Low) → 보통(Medium) → 높음(High) → 결정적(Critical)</p>

<h3 id="애플리케이션-성능-개선">애플리케이션 성능 개선</h3>

<ul>
  <li>tch: 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답 시간 저하 현상 발생</li>
  <li>연결 누수(Connection Leak): DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생</li>
  <li>부적절한 커넥션 풀 크기(Connection Pool Size): 너무 작거나 크게 설정한 경우 성능 저하 현상이 발생할 가능성 존재</li>
  <li>확정(Commint) 관련: 트랜잭션이 확정 되지 않고 커넥션 풀에 반환될 떄 성능 저하 가능성 존재</li>
</ul>

<h4 id="베드-코드bad-code-프로그램-로직이-복잡하고-다른-개발자들이-이해하기-어려운-코드">베드 코드(Bad Code): 프로그램 로직이 복잡하고 다른 개발자들이 이해하기 어려운 코드</h4>

<ul>
  <li>베드 코드 사례
    <ul>
      <li>외계인 코드: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드</li>
      <li>스파게티 코드: 소스 코드가 복잡하게 얽힌 모습, 정상 작동 하지만 코드의 작동을 파악하기 어려운 코드</li>
      <li>알 수 없는 변수명: 변수나 메서드에 대한 이름 정의를 알 수 없는 코드</li>
      <li>로직 중복: 동일한 처리 로직이 중복되게 작성된 코드</li>
    </ul>
  </li>
</ul>

<h4 id="클린-코드clean-code">클린 코드(Clean Code)</h4>

<p>가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드</p>

<ul>
  <li>클린 코드 특징: 가독성이 높아 쉽게 이해됨, 개선도 쉬움, 버그찾기도 쉬워 프래그래밍 속도 빨라짐</li>
  <li>클린 코드 작성 원칙: 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화</li>
</ul>

<h4 id="리팩토링refactoring">리팩토링(Refactoring)</h4>

<p>기능을 변경하지 않고, 복잡한 소스코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법</p>

<p class="notice--success">🔔<strong>포스팅 공지</strong><br />
개인 공부 기록용 블로그 입니다.<br />
잘못된 부분이 있을 시 메일이나 댓글로 지적해주시면 감사드리겠습니다 :)</p>]]></content><author><name>LIME</name><email>ilimes1307@gmail.com</email></author><category term="InfoProcessing" /><category term="정보처리기사" /><category term="정처기" /><category term="테스트" /><category term="애플리케이션" /><category term="개발" /><summary type="html"><![CDATA[정보처리기사 - 애플리케이션 테스트 관리]]></summary></entry></feed>